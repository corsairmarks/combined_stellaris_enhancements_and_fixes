namespace = keep_leaders

# triggered by keep_leaders.2, keep_leaders.5, keep_leaders.21, keep_leaders.51
# window with options to potentially keep the stored leaders from integration/pre-FTL conquest/colossus weapon
# root = country, overlord
# from = country, integrated subject or conquered/colossus'd pre-FTLs
# fromfrom = planet, pre-FTL world (if available)
country_event = {
	id = keep_leaders.1
	title = keep_leaders.1.title.scripted_loc
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_gestalt = no
			event_target:storage_owner = { has_country_flag = regular_empire_or_primitive_storage_owner }
		}
		text = keep_leaders.1.desc.integration.regular_by_regular
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_gestalt = yes
			event_target:storage_owner = { has_country_flag = regular_empire_or_primitive_storage_owner }
		}
		text = keep_leaders.1.desc.integration.regular_by_gestalt
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_hive_empire = no
			is_machine_empire = no
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.hive_by_regular
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_hive_empire = yes
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.hive_by_hive
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_machine_empire = yes
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.hive_by_machine
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_hive_empire = no
			is_machine_empire = no
			event_target:storage_owner = { has_country_flag = machine_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.machine_by_regular
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_hive_empire = yes
			event_target:storage_owner = { has_country_flag = machine_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.machine_by_hive
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_integration@event_target:storage_owner
			is_machine_empire = yes
			event_target:storage_owner = { has_country_flag = machine_empire_storage_owner }
		}
		text = keep_leaders.1.desc.integration.machine_by_machine
	}
	# TODO: clean space once done with options




	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@event_target:storage_owner
			is_gestalt = no
			event_target:storage_owner = { has_country_flag = regular_empire_or_primitive_storage_owner }
		}
		text = keep_leaders.1.desc.conquest.regular_by_regular
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@event_target:storage_owner
			is_gestalt = yes
			event_target:storage_owner = { has_country_flag = regular_empire_or_primitive_storage_owner }
		}
		text = keep_leaders.1.desc.conquest.regular_by_gestalt
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@event_target:storage_owner
			is_hive_empire = no
			is_machine_empire = no
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.conquest.hive_by_regular
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@event_target:storage_owner
			is_hive_empire = yes
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.conquest.hive_by_hive
	}
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@event_target:storage_owner
			is_machine_empire = yes
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.1.desc.conquest.hive_by_machine
	}
	# note: if/when machine pre-FTLs are added, this event will need additional descriptions for conquest
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = orbitally_drenched@fromfrom
			}
		}
		text = keep_leaders.1.desc.planet_killer_deluge
	}
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = divinely_enforced@fromfrom
			}
		}
		text = keep_leaders.1.desc.planet_killer_godray
	}
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				NOR = {
					has_country_flag = orbitally_drenched@fromfrom
					has_country_flag = divinely_enforced@fromfrom
					has_country_flag = nanobot_assimilated@fromfrom
					has_country_flag = orbitally_necrophaged@fromfrom
				}
			}
		}
		text = keep_leaders.1.desc.planet_killer_generic
	}
	auto_opens = no
	# location = fromfrom # optional way to do this?
	# despite show_sound being a valid part of a triggered desc, the game didn't seem to like it (as a guess, no fallback?)
	show_sound = {
		trigger = {
			OR = {
				has_country_flag = keeping_leaders_conquest@event_target:storage_owner
				has_country_flag = keeping_leaders_integration@event_target:storage_owner
			}
		}
		sound = event_radio_chatter
	}
	show_sound = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = orbitally_drenched@fromfrom
			}
		}
		sound = aqu_wep_colossus_planet_hit
	}
	show_sound = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = divinely_enforced@fromfrom
			}
		}
		sound = event_mystic_reveal
	}
	show_sound = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				NOR = {
					has_country_flag = orbitally_drenched@fromfrom
					has_country_flag = divinely_enforced@fromfrom
					has_country_flag = nanobot_assimilated@fromfrom
					has_country_flag = orbitally_necrophaged@fromfrom
				}
			}
		}
		sound = event_red_alert
	}
	picture = {
		picture = GFX_leader_recruitment_bg_integration # GFX_evt_intelligence_report
		trigger = { has_country_flag = keeping_leaders_integration@event_target:storage_owner }
	}
	picture = {
		picture = GFX_leader_recruitment_bg_invasion # GFX_evt_intelligence_report
		trigger = { has_country_flag = keeping_leaders_conquest@event_target:storage_owner }
	}
	picture = {
		picture = GFX_leader_recruitment_bg_deluge # GFX_evt_planet_beam
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = orbitally_drenched@fromfrom
			}
		}
	}
	picture = {
		picture = GFX_leader_recruitment_bg_planet_destruction # GFX_evt_death_from_above
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			event_target:storage_owner = {
				has_country_flag = colossus_transfer@fromfrom
				NOT = { has_country_flag = orbitally_drenched@fromfrom }
			}
		}
	}
	event_window_type = leader_recruit
	notification_event_icon = GFX_message_keep_leaders
	picture_event_data = {
		portrait = event_target:transfer_representative
		room = ethic_spaceship_room
	}
	is_triggered_only = yes
	trigger = {
		exists = from
		any_country = {
			has_country_flag = former_owner@from
			any_owned_leader = {
				has_leader_flag = former_owner@from
				has_leader_flag = potential_owner@prevprev
			}
		}
	}
	immediate = {
		log = "country [This.GetRealName] retaining leaders from [From.GetRealName]"
		# "argument" for choose_transfer_representative_leader and others
		save_event_target_as = potential_owner
		from = {
			save_event_target_as = former_owner
			owner_species = { save_event_target_as = original_species }
			fromfrom = { save_event_target_as = conquered_planet } # "argument" for localisation
		}
		# acquire leader and variable storage
		random_country = {
			limit = { has_country_flag = former_owner@from }
			save_event_target_as = storage_owner
			save_event_target_as = variable_storage
		}
		choose_transfer_representative_leader = yes
	}
	option = { # dismiss_leader (none; mean for everyone except pacifists/xenophiles)
		tag = dismiss_leader
		name = { # standard mean option
			text = keep_leaders.1.a
			trigger = {
				# not any of the others
				NOR = {
					AND = {
						OR = {
							has_valid_civic = civic_fanatic_purifiers
							has_valid_civic = civic_hive_devouring_swarm
						}
						event_target:storage_owner = { all_stored_leaders_same_species = yes }
					}
					AND = {
						is_valid_organic_zealots = yes
						event_target:storage_owner = { all_stored_leaders_robotic = yes }
					}
					AND = {
						has_valid_civic = civic_machine_terminator
						event_target:storage_owner = { all_stored_leaders_organic = yes }
					}
					AND = {
						has_valid_civic = civic_machine_servitor
						event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
					}
					AND = {
						is_regular_hive_empire = yes
						event_target:storage_owner = { all_stored_leaders_hive = yes }
					}
					AND = {
						is_machine_empire = yes
						event_target:storage_owner = { all_stored_leaders_robotic = yes }
					}
				}
				is_pacifist = no
				is_xenophile = no
			}
		}
		name = { # pacifist/xenophile nice option
			text = keep_leaders.1.b.short
			trigger = {
				OR = {
					is_pacifist = yes
					is_xenophile = yes
				}
			}
		}
		name = { # civic_fanatic_purifiers
			text = keep_leaders.1.a.pur
			trigger = {
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { has_any_stored_leaders_same_species = no }
			}
		}
		name = { # civic_hive_devouring_swarm
			text = keep_leaders.1.a.swarm
			trigger = {
				has_valid_civic = civic_hive_devouring_swarm
				event_target:storage_owner = { has_any_stored_leaders_same_species = no }
			}
		}
		name = { # civic_organic_zealots
			text = keep_leaders.1.a.zeal
			trigger = {
				is_valid_organic_zealots = yes
				event_target:storage_owner = { all_stored_leaders_robotic = yes }
			}
		}
		name = { # civic_machine_terminator
			text = keep_leaders.1.a.term.short
			trigger = {
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = { all_stored_leaders_organic = yes }
			}
		}
		name = { # civic_machine_servitor + any non-hive bio
			text = keep_leaders.1.a.serv.short
			trigger = {
				has_valid_civic = civic_machine_servitor
				event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
			}
		}
		name = { # gestalt "drones only"
			text = keep_leaders.1.a.gest.exclusive
			trigger = {
				OR = {
					AND = {
						is_regular_hive_empire = yes
						event_target:storage_owner = { all_stored_leaders_hive = yes }
					}
					AND = {
						is_devouring_hive_empire = yes
						event_target:storage_owner = { all_stored_leaders_same_species = yes }
					}
					AND = {
						is_machine_empire = yes
						event_target:storage_owner = { all_stored_leaders_robotic = yes }
					}
				}
			}
		}
		if = {
			limit = {
				is_devouring_hive_empire = yes
				event_target:storage_owner = { all_stored_leaders_same_species = no }
			}
			custom_tooltip = keep_leaders.1.a.swarm.tooltip
		}
		else_if = {
			limit = {
				OR = {
					AND = {
						is_hive_empire = yes
						event_target:storage_owner = {
							OR = {
								all_stored_leaders_hive = yes
								all_stored_leaders_same_species = yes
							}
						}
					}
					AND = {
						is_machine_empire = yes
						event_target:storage_owner = { all_stored_leaders_robotic = yes }
					}
				}
			}
			custom_tooltip = keep_leaders.1.a.gest.exclusive.tooltip
		}
		else_if = {
			limit = {
				has_valid_civic = civic_machine_servitor
				event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
			}
			custom_tooltip = keep_leaders.1.a.serv.tooltip
		}
		else_if = {
			limit = {
				OR = {
					is_pacifist = yes
					is_xenophile = yes
				}
			}
			custom_tooltip = keep_leaders.1.b.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.a.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				hidden_trigger = { always = yes }
				# icons!
				has_valid_civic = civic_fanatic_purifiers
				has_valid_civic = civic_hive_devouring_swarm
				has_valid_civic = civic_machine_terminator
				AND = {
					has_valid_civic = civic_machine_servitor
					hidden_trigger = { event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes } }
				}
				AND = {
					is_gestalt = yes
					hidden_trigger = {
						OR = {
							AND = {
								is_hive_empire = yes
								event_target:storage_owner = { all_stored_leaders_hive = yes }
							}
							AND = {
								is_machine_empire = yes
								event_target:storage_owner = { all_stored_leaders_robotic = yes }
							}
						}
					}
				}
			}
		}
		klfis_try_generate_rewards_fanatic_purifiers = yes
		klfis_try_generate_rewards_organic_zealots = yes
		klfis_try_generate_rewards_hive_devouring_swarm = yes
		klfis_try_generate_rewards_machine_terminator = yes
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0.5
				klfis_is_necrophage_empire = yes
			}
			modifier = {
				factor = 3
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
			modifier = {
				factor = 20
				has_valid_civic = civic_hive_devouring_swarm
			}
			modifier = {
				factor = 5
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = { has_any_stored_leaders_organic = yes }
			}
			modifier = {
				factor = 100
				has_valid_civic = civic_inwards_perfection
			}
		}
	}
	option = { # none (nice option for non-pacifists/non-xenophiles, swapped to mean text for pacifists/xenophiles and disallowed)
		name = {
			text = keep_leaders.1.b
			trigger = {
				is_pacifist = no
				is_xenophile = no
			}
		}
		name = {
			text = keep_leaders.1.a
			trigger = {
				OR = {
					is_pacifist = yes
					is_xenophile = yes
				}
			}
		}
		if = {
			limit = {
				is_pacifist = no
				is_xenophile = no
			}
			custom_tooltip = keep_leaders.1.b.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.a.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				is_valid_organic_zealots = no
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				klfis_is_necrophage_empire = yes
			}
		}
	}
	option = { # hire_leader (includes most of the "keep some" options)
		tag = hire_leader
		name = { # standard "keep all"
			text = keep_leaders.1.j
			trigger = {
				OR = {
					AND = {
						OR = {
							has_valid_civic = civic_fanatic_purifiers
							has_valid_civic = civic_hive_devouring_swarm
						}
						event_target:storage_owner = { has_any_stored_leaders_same_species = no }
					}
					AND = {
						is_valid_organic_zealots = yes
						event_target:storage_owner = {
							OR = {
								all_stored_leaders_organic = yes
								all_stored_leaders_robotic = yes
							}
						}
					}
					AND = {
						has_valid_civic = civic_machine_terminator
						event_target:storage_owner = { has_any_stored_leaders_robotic = no }
					}
					AND = {
						has_valid_civic = civic_machine_servitor
						has_battle_thrall_military_leaders_active = no
						event_target:storage_owner = { all_stored_leaders_organic_non_hive = yes }
					}
					AND = {
						is_regular_empire = yes
						is_homicidal = no
					}
				}
			}
		}
		name = { # purifier all same species
			text = keep_leaders.1.j.pur
			trigger = {
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { all_stored_leaders_same_species = yes }
			}
		}
		name = { # purifier mixed
			text = keep_leaders.1.g.pur
			trigger = {
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = {
					has_any_stored_leaders_same_species = yes
					all_stored_leaders_same_species = no
				}
			}
		}
		name = { # zealot mixed
			text = keep_leaders.1.e.zeal
			trigger = {
				is_valid_organic_zealots = yes
				event_target:storage_owner = {
					has_any_stored_leaders_organic = yes
					all_stored_leaders_organic = no
				}
			}
		}
		name = { # terminator mixed
			text = keep_leaders.1.c.term
			trigger = {
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = { has_stored_leaders_both_robotic_and_organic = yes }
			}
		}
		name = { # servitor mixed (no BTML)
			text = keep_leaders.1.d.serv.short
			trigger = {
				has_valid_civic = civic_machine_servitor
				has_battle_thrall_military_leaders_active = no
				event_target:storage_owner = { has_stored_leaders_both_robotic_and_organic_non_hive = yes }
			}
		}
		name = { # servitor mixed (BTML)
			text = keep_leaders.1.j.serv
			trigger = {
				has_valid_civic = civic_machine_servitor
				has_battle_thrall_military_leaders_active = yes
				event_target:storage_owner = { has_stored_leaders_both_robotic_and_organic_non_hive = yes }
			}
		}
		name = { # servitor only organic (BTML)
			text = keep_leaders.1.e.serv.exclusive.short
			trigger = {
				has_valid_civic = civic_machine_servitor
				has_battle_thrall_military_leaders_active = yes
				event_target:storage_owner = { all_stored_leaders_organic_non_hive = yes }
			}
		}
		name = { # hive mixed
			text = keep_leaders.1.i.hive
			trigger = {
				is_hive_empire = yes
				hidden_trigger = {
					NOT = { has_valid_civic = civic_hive_devouring_swarm }
					event_target:storage_owner = {
						has_any_stored_leaders_hive = yes
						all_stored_leaders_hive = no
					}
				}
			}
		}
		name = { # hive only hive
			text = keep_leaders.1.i.hive.exclusive
			trigger = {
				is_hive_empire = yes
				hidden_trigger = {
					NOT = { has_valid_civic = civic_hive_devouring_swarm }
					event_target:storage_owner = { all_stored_leaders_hive = yes }
				}
			}
		}
		name = { # machine mixed
			text = keep_leaders.1.c.mach
			trigger = {
				is_machine_empire = yes
				NOR = {
					has_valid_civic = civic_machine_servitor
					has_valid_civic = civic_machine_terminator
				}
				event_target:storage_owner = {
					has_any_stored_leaders_robotic = yes
					all_stored_leaders_robotic = no
				}
			}
		}
		name = { # machine only machine
			text = keep_leaders.1.c.mach.exclusive
			trigger = {
				is_machine_empire = yes
				event_target:storage_owner = { all_stored_leaders_robotic = yes }
			}
		}
		if = {
			limit = {
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { has_any_stored_leaders_same_species = yes }
			}
			if = {
				limit = { event_target:storage_owner = { all_stored_leaders_same_species = yes } }
				custom_tooltip = keep_leaders.1.j.pur.tooltip
			}
			else = {
				custom_tooltip = keep_leaders.1.g.pur.tooltip
			}
		}
		else_if = {
			limit = {
				is_valid_organic_zealots = yes
				event_target:storage_owner = {
					has_any_stored_leaders_organic = yes
					all_stored_leaders_organic = no
				}
			}
			custom_tooltip = keep_leaders.1.e.tooltip
		}
		else_if = {
			limit = {
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = { has_stored_leaders_both_robotic_and_organic = yes }
			}
			custom_tooltip = keep_leaders.1.c.term.tooltip
		}
		else_if = {
			limit = {
				has_valid_civic = civic_machine_servitor
				event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
				OR = {
					has_battle_thrall_military_leaders_active = yes
					event_target:storage_owner = { has_any_stored_leaders_robotic = yes }
				}
			}
			if = {
				limit = { event_target:storage_owner = { has_any_stored_leaders_robotic = yes } }
				if = {
					limit = { has_battle_thrall_military_leaders_active = no }
					custom_tooltip = keep_leaders.1.d.serv.tooltip
				}
				else = {
					custom_tooltip = keep_leaders.1.j.serv.tooltip
				}
			}
			else = {
				custom_tooltip = keep_leaders.1.e.serv.exclusive.tooltip
			}
		}
		else_if = {
			limit = {
				is_hive_empire = yes
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
				event_target:storage_owner = { has_any_stored_leaders_hive = yes }
			}
			if = {
				limit = { event_target:storage_owner = { all_stored_leaders_hive = yes } }
				custom_tooltip = keep_leaders.1.i.hive.exclusive.tooltip
			}
			else = {
				custom_tooltip = keep_leaders.1.i.hive.tooltip
			}
		}
		else_if = {
			limit = {
				is_machine_empire = yes
				NOT = { has_valid_civic = civic_machine_terminator }
				event_target:storage_owner = { has_any_stored_leaders_robotic = yes }
			}
			if = {
				limit = { event_target:storage_owner = { all_stored_leaders_robotic = yes } }
				if = {
					limit = { has_valid_civic = civic_machine_assimilator }
					custom_tooltip = keep_leaders.1.c.assim.exclusive.tooltip
				}
				else = {
					custom_tooltip = keep_leaders.1.c.mach.exclusive.tooltip
				}
			}
			else = {
				custom_tooltip = keep_leaders.1.c.mach.tooltip
			}
		}
		else = {
			custom_tooltip = keep_leaders.1.j.tooltip
		}
		if = {
			limit = {
				OR = {
					has_valid_civic = civic_fanatic_purifiers
					has_valid_civic = civic_hive_devouring_swarm
				}
			}
			retain_leaders_same_species_effect = yes
		}
		else_if = {
			limit = { is_valid_organic_zealots = yes }
			retain_leaders_organic_only_effect = yes
		}
		else_if = {
			limit = { is_hive_empire = yes }
			retain_leaders_hive_only_effect = yes
		}
		else_if = {
			limit = {
				is_machine_empire = yes
				OR = {
					NOT = { has_valid_civic = civic_machine_servitor }
					has_battle_thrall_military_leaders_active = no
				}
			}
			retain_leaders_robotic_only_effect = yes
		}
		else = {
			retain_leaders_all_non_assimilation_effect = yes
		}
		trigger = {
			OR = {
				hidden_trigger  = { always = yes }
				# icons!
				AND = {
					OR = {
						has_valid_civic = civic_fanatic_purifiers
						has_valid_civic = civic_hive_devouring_swarm
					}
					hidden_trigger = { event_target:storage_owner = { has_any_stored_leaders_same_species = yes } }
				}
				AND = {
					is_valid_organic_zealots = yes
					hidden_trigger = { event_target:storage_owner = { has_any_stored_leaders_robotic = yes } }
				}
				AND = {
					has_valid_civic = civic_machine_terminator
					hidden_trigger = { event_target:storage_owner = { has_any_stored_leaders_organic = yes } }
				}
				AND = {
					has_valid_civic = civic_machine_servitor
					hidden_trigger = { event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes } }
				}
				AND = {
					is_machine_empire = yes
					hidden_trigger = {
						NAND = {
							OR = {
								has_valid_civic = civic_machine_terminator
								has_valid_civic = civic_machine_servitor
							}
							event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
						}
					}
				}
				AND = {
					is_hive_empire = yes
					hidden_trigger = { NOT = { has_valid_civic = civic_hive_devouring_swarm } }
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = {
						klfis_is_necrophage_empire = yes
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
							}
						}
					}
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = {
						is_xenophobe = yes
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
							}
						}
					}
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { has_any_stored_leaders_same_species = no }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.zeal.fail_text
				if = {
					limit = { is_valid_organic_zealots = yes }
					event_target:storage_owner = { all_stored_leaders_robotic = no }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.term.fail_text
				if = {
					limit = { has_valid_civic = civic_machine_terminator }
					event_target:storage_owner = { all_stored_leaders_organic = no }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.serv.fail_text
				if = {
					limit = {
						has_valid_civic = civic_machine_servitor
						has_battle_thrall_military_leaders_active = no
					}
					event_target:storage_owner = { all_stored_leaders_organic = no }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				if = {
					limit = { has_valid_civic = civic_hive_devouring_swarm }
					event_target:storage_owner = {
						has_any_stored_leaders_non_hive = yes
						has_any_stored_leaders_same_species = no
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.hive.fail_text
				if = {
					limit = { has_valid_civic = civic_hive_devouring_swarm }
					event_target:storage_owner = {
						all_stored_leaders_hive = yes
						has_any_stored_leaders_same_species = no
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.hive.fail_text
				if = {
					limit = { is_regular_hive_empire = yes }
					event_target:storage_owner = { has_any_stored_leaders_hive = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.mach.fail_text
				if = {
					limit = {
						is_machine_empire = yes
						NOR = {
							has_valid_civic = civic_machine_terminator
							has_valid_civic = civic_machine_servitor
						}
					}
					event_target:storage_owner = { has_any_stored_leaders_organic_non_hive = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.j.fail_text
				event_target:variable_storage = {
					check_variable = {
						which = leader_transferable_accumulator
						value > 0
					}
				}
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				is_pacifist = yes
			}
			modifier = {
				factor = 2
				is_xenophile = yes
			}
			modifier = {
				factor = 2
				allows_ai_leaders = yes
				event_target:storage_owner = { has_any_stored_leaders_robotic = yes }
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_inwards_perfection
			}
			modifier = {
				factor = 20
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { all_stored_leaders_same_species = yes }
			}
			modifier = {
				factor = 10
				has_valid_civic = civic_machine_servitor
			}
		}
	}
	option = { # keep robotic only (non-cybernetic empire) - non-assimilation
		name = keep_leaders.1.c
		custom_tooltip = keep_leaders.1.c.tooltip
		retain_leaders_robotic_only_effect = yes
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOR = {
					has_valid_civic = civic_fanatic_purifiers
					has_active_tradition = tr_cybernetics_transubstantiation_synthesis
				}
				is_valid_organic_zealots = no
				event_target:storage_owner = {
					has_any_stored_leaders_organic_non_hive = yes
					has_any_stored_leaders_robotic = yes
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_robotic_species } }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_robotic_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 0
				is_spiritualist = yes
			}
		}
	}
	option = { # keep robotic only (assimilator) - non-assimilation
		name = keep_leaders.1.c.assim
		custom_tooltip = keep_leaders.1.c.assim.tooltip
		retain_leaders_robotic_only_effect = yes
		trigger = {
			has_valid_civic = civic_machine_assimilator
			hidden_trigger = {
				event_target:storage_owner = {
					has_any_stored_leaders_organic_non_hive = yes
					has_any_stored_leaders_robotic = yes
				}
			}
		}
	}
	option = { # keep robotic only (nice) - non-assimilation
		name = {
			text = keep_leaders.1.d
			trigger = { NOT = { has_valid_civic = civic_machine_servitor } }
		}
		name = {
			text = keep_leaders.1.d.serv
			trigger = { has_valid_civic = civic_machine_servitor }
		}
		if = {
			limit = { has_valid_civic = civic_machine_servitor }
			custom_tooltip = keep_leaders.1.d.serv.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.d.tooltip
		}
		retain_leaders_robotic_only_effect = yes
		trigger = {
			OR = {
				AND = {
					has_valid_civic = civic_machine_servitor
					hidden_trigger = { has_battle_thrall_military_leaders_active = yes }
				}
				hidden_trigger = {
					is_regular_empire = yes
					NOT = { has_valid_civic = civic_fanatic_purifiers }
					is_valid_organic_zealots = no
				}
			}
			hidden_trigger = {
				event_target:storage_owner = {
					has_any_stored_leaders_organic_non_hive = yes
					has_any_stored_leaders_robotic = yes
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_robotic_species } }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_robotic_species } }
				}
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				is_materialist = yes
			}
			modifier = {
				factor = 0
				is_spiritualist = yes
			}
			modifier = {
				factor = 4
				has_valid_civic = civic_machine_servitor
			}
		}
	}
	option = { # keep organic only - non-assimilation
		name = {
			text = keep_leaders.1.e
			trigger = {
				is_spiritualist = no
				is_valid_organic_zealots = no
				allows_ai_leaders = no
			}
		}
		name = {
			text = keep_leaders.1.e.zeal
			trigger = {
				is_spiritualist = yes
				allows_ai_leaders = no
			}
		}
		name = {
			text = keep_leaders.1.e.ai
			trigger = { allows_ai_leaders = yes }
		}
		name = {
			text = keep_leaders.1.e.serv
			trigger = { has_valid_civic = civic_machine_servitor }
		}
		if = {
			limit = { has_valid_civic = civic_machine_servitor }
			custom_tooltip = keep_leaders.1.e.serv.tooltip
		}
		else_if = {
			limit = { allows_ai_leaders = no }
			custom_tooltip = keep_leaders.1.e.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.e.ai.tooltip
		}
		retain_leaders_organic_only_effect = yes
		trigger = {
			OR = {
				has_valid_civic = civic_machine_servitor
				hidden_trigger = {
					is_regular_empire = yes
					NOT = { has_valid_civic = civic_fanatic_purifiers }
					is_valid_organic_zealots = no
				}
			}
			hidden_trigger = {
				OR = {
					NOT = { has_valid_civic = civic_machine_servitor }
					has_battle_thrall_military_leaders_active = yes
				}
				event_target:storage_owner = {
					has_any_stored_leaders_organic_non_hive = yes
					has_any_stored_leaders_robotic = yes
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_non_robotic_non_hive_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_non_robotic_non_hive_species } }
				}
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				is_spiritualist = yes
			}
			modifier = {
				factor = 0
				is_materialist = yes
			}
			complex_trigger_modifier = {
				trigger = count_owned_leader
				trigger_scope = event_target:storage_owner
				parameters = {
					limit = {
						is_eligible_transfer_leader_from_storage = yes
						is_non_robotic_non_hive_species = yes
						klfis_has_species_trait_with_leader_trait = yes
					}
				}
				mode = add
				mult = 5
				potential = { has_valid_civic = civic_machine_servitor }
			}
		}
	}
	option = { # same species only
		name = keep_leaders.1.g
		custom_tooltip = keep_leaders.1.g.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					all_stored_leaders_same_species = no
					has_any_stored_leaders_same_species = yes
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_fanatic_purifiers
			}
			modifier = {
				factor = 0.5
				klfis_is_necrophage_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # same species only (nice)
		name = keep_leaders.1.h
		custom_tooltip = keep_leaders.1.h.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					all_stored_leaders_same_species = no
					has_any_stored_leaders_same_species = yes
				}
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 0.5
				is_xenophobe = yes
			}
			modifier = {
				factor = 4
				klfis_is_necrophage_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: hive
		name = keep_leaders.1.k.hive
		icon = {
			icon = GFX_ap_engineered_evolution
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.hive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.hive.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_genetic_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_engineered_evolution
			hidden_trigger = {
				is_hive_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_hive_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_genetic_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				is_potential_for_genetic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_hive_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
			}
		}
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.19
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: unhive
		name = keep_leaders.1.k.unhive
		icon = {
			icon = GFX_ap_engineered_evolution
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unhive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.unhive.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_genetic_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_engineered_evolution
			hidden_trigger = {
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_unhive_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_genetic_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				is_potential_for_genetic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unhive_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unhive_assimilation_species } }
				}
			}
		}
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.19
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: psionic
		name = keep_leaders.1.k.psi
		icon = {
			icon = GFX_ap_mind_over_matter
			text = keep_leaders.1.k.psi.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.psi.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.psi.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_psionic_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				has_ascension_perk = ap_mind_over_matter
				has_origin = origin_shroudwalker_apprentice
			}
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_psionic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_psionic_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.psionic.fail_text
				is_potential_for_psionic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_psionic_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_psionic_assimilation_species } }
				}
			}
		}
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.18
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: cybernetic (non-hive)
		name = keep_leaders.1.k.cyb
		icon = {
			icon = GFX_ap_the_flesh_is_weak
			text = keep_leaders.1.k.cyb.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.cyb.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_cyborg_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_the_flesh_is_weak
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_regular_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_cyborg_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb.fail_text
				is_potential_for_cyborg_assimilation_country = yes
			}
			if = {
				limit = { has_civic_organic_zealots_active = yes }
				is_not_restricted_by_organic_zealots = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_regular_cyborg_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_regular_cyborg_assimilation_species } }
				}
			}
		}
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: cybernetic (hive)
		name = {
			text = keep_leaders.1.k.cyb.hive
			trigger = { event_target:transfer_representative = { is_hive_species = no } }
		}
		name = {
			text = keep_leaders.1.k.cyb.hive.hive
			trigger = { event_target:transfer_representative = { is_hive_species = yes } }
		}
		icon = {
			icon = GFX_ap_organo_machine_interfacing
			text = keep_leaders.1.k.cyb.hive.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.cyb.hive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.cyb.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_cyborg_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_organo_machine_interfacing
			hidden_trigger = {
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_hive_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_cyborg_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb.fail_text
				is_potential_for_cyborg_assimilation_country = yes
			}
			if = {
				limit = { has_civic_organic_zealots_active = yes }
				is_not_restricted_by_organic_zealots = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_hive_cyborg_assimilation_species } }
				}
			}
		}
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: synthetic (non-machine)
		name = keep_leaders.1.k.synth
		icon = {
			icon = GFX_ap_synthetic_evolution
			text = keep_leaders.1.k.synth.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.synth.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.synth.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_synthetic_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_synthetic_evolution
			hidden_trigger = {
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_regular_synthetic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_synthetic_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth1.fail_text
				has_active_tradition = tr_synthetics_synthetic_age
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth2.fail_text
				has_country_flag = synth_assimilation
			}
		}
		ai_chance = {
			base = 10
			modifier = {
				factor = 0.5
				is_xenophile = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: synthetic (machine)
		name = keep_leaders.1.k.synth.mach
		icon = {
			icon = GFX_ap_synthetic_age
			text = keep_leaders.1.k.synth.mach.icon.tooltip
		}
		if = {
			limit = { NOT = { has_valid_civic = civic_machine_assimilator } }
			custom_tooltip = keep_leaders.1.k.synth.mach.tooltip
		}
		else_if = {
			limit = { NOT = { has_active_tradition = tr_cybernetics_assimilator_inevitable_assimilation } }
			custom_tooltip = keep_leaders.1.k.synth.assim.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.synth.assim.ia.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.synth.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_synthetic_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_synthetic_age
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_machine_synthetic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_synthetic_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth.mach.fail_text
				has_active_tradition = tr_synthetics_adopt_machine
			}
		}
		klfis_try_generate_rewards_machine_assimilator = yes
		klfis_try_generate_rewards_machine_terminator = yes
		ai_chance = { base = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: assimilator
		name = keep_leaders.1.k.assim
		if = {
			limit = { NOT = { has_active_tradition = tr_cybernetics_assimilator_inevitable_assimilation } }
			custom_tooltip = keep_leaders.1.k.assim.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.assim.ia.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.cyb.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_cyborg_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_valid_civic = civic_machine_assimilator
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_machine_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_cyborg_allowable_accumulator
						value > 0
					}
				}
			}
		}
		ai_chance = { base = 20 }
		klfis_try_generate_rewards_machine_assimilator = yes
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: unmachine
		name = keep_leaders.1.k.unmach
		icon = {
			icon = GFX_icon_tech_sapient_ai_alternate
			text = keep_leaders.1.k.unmach.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unmach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.unmach.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_unmachine_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_technology = tech_sapient_ai
			hidden_trigger = {
				has_synthethic_dawn = yes
				has_deassimilate_machines_active = yes
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_unmachine_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_unmachine_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			if = {
				limit = { has_civic_organic_zealots_active = yes }
				is_not_restricted_by_organic_zealots = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				klfis_is_necrophage_empire = no
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unmachine_assimilation_species } }
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # assimilate: uncyborg
		name = {
			text = keep_leaders.1.k.uncyb
			trigger = { is_valid_organic_zealots = no }
		}
		name = {
			text = keep_leaders.1.k.uncyb.zeal
			trigger = { is_valid_organic_zealots = yes }
		}
		icon = {
			icon = GFX_icon_tech_gene_banks_alternate
			text = keep_leaders.1.k.uncyb.icon.tooltip
		}
		if = {
			limit = { is_valid_organic_zealots = no }
			custom_tooltip = keep_leaders.1.k.uncyb.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.uncyb.zeal.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.uncyb.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_assimilation_uncyborg_allowable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]" # no special count, it's in addition to existing transformations
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_technology = tech_gene_tailoring
			has_technology = tech_gene_banks
			hidden_trigger = {
				OR = {
					has_synthethic_dawn = yes
					has_utopia = yes
				}
				has_civic_organic_zealots_active = yes
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_uncyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_assimilation_uncyborg_allowable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { klfis_is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_uncyborg_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_uncyborg_assimilation_species } }
				}
			}
		}
		ai_chance = {
			base = 0
			modifier = {
				add = 50
				is_valid_organic_zealots = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.13
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = { # necrophage (kinda like assimilation in terms of the outcome)
		name = keep_leaders.1.k.necro
		if = {
			limit = { is_hive_empire = no }
			custom_tooltip = keep_leaders.1.k.necro.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.necro.hive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.k.necro.count.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = { has_necroids = yes }
			klfis_is_necrophage_empire = yes
		}
		allow = {
			custom_tooltip = {
				fail_text = NECROPHAGE_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = CANNOT_NECROPHAGE_MACHINES_NO_X
				event_target:storage_owner = { all_stored_leaders_robotic = no }
			}
		}
		ai_chance = {
			base = 10
			modifier = {
				factor = 2
				has_policy_flag = purge_allowed
			}
		}
		klfis_try_generate_rewards_origin_necrophage = yes
		hidden_effect = {
			country_event = {
				id = keep_leaders.20
				scopes = { from = event_target:storage_owner }
			}
		}
	}
}

# triggered by on_planet_attackers_win (same on_action as pre-FTL planet conquest action.14)
# root = country, leader attacker
# from = country, planet owner
# fromfrom = planet
country_event = {
	id = keep_leaders.2
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		any_playable_country = { is_country = prev }
		exists = from
		from = {
			is_primitive = yes
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader = yes }
			}
		}
	}
	immediate = {
		log = "pre-FTL conquest: [FromFrom.GetName] ([From.GetRealName]) conquered by [This.GetRealName]"
		save_event_target_as = potential_owner # "argument" for create_leader_storage_and_transfer_leaders
		from = { save_event_target_as = former_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
		set_country_flag = keeping_leaders_conquest@event_target:storage_owner
		country_event = {
			id = keep_leaders.1 # hooray for reuse!
			scopes = {
				from = from
				fromfrom = fromfrom
			}
		}
	}
}

# window with options to potentially keep the stored leaders from infiltration
# triggered by on_planet_transfer
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.3
	title = keep_leaders.3.title
	desc = {
		trigger = {
			exists = from
			from = { has_appearance_modding_technology = no }
		}
		text = keep_leaders.3.desc
	}
	desc = {
		trigger = {
			exists = from
			from = { has_appearance_modding_technology = yes }
		}
		text = keep_leaders.3.desc.appearance_mod
	}
	auto_opens = no
	location = this
	show_sound = event_espionage_concluded
	picture = GFX_leader_recruitment_bg_infiltration # GFX_evt_diplomatic_visit
	event_window_type = leader_recruit
	notification_event_icon = GFX_message_keep_leaders
	picture_event_data = {
		portrait = event_target:transfer_representative
		room = ethic_spaceship_room
	}
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_modifier = infiltration_happiness
		exists = from
		exists = fromfrom
		fromfrom = {
			is_scope_type = country
			is_primitive = yes
		}
	}
	immediate = {
		log = "pre-FTL infiltration: [This.GetName] ([FromFrom.GetRealName]) infiltrated by [From.GetRealName]"
		from = { set_country_flag = keeping_leaders_infiltration@fromfrom }
		fromfrom = {
			save_event_target_as = former_owner # "argument" for localisation and create_leader_storage_and_transfer_leaders
			owner_species = { save_event_target_as = original_species } # "argument" for localisation
		}
		from = { save_event_target_as = potential_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
		choose_transfer_representative_leader = yes
		if = {
			limit= { from = { has_appearance_modding_technology = yes } }
			# prepare the representative in advance; infiltrator_retain_cover intentionally not set
			event_target:transfer_representative = { prepare_to_retain_infiltration_leader = { RETAIN_COVER = yes } }
		}
	}
	option = {
		tag = dismiss_leader
		name = keep_leaders.3.d
		custom_tooltip = keep_leaders.3.d.tooltip
		hidden_effect = {
			event_target:storage_owner = { try_clean_up_leader_storage = yes }
			erase_modifier = { MOD = kl_peerless_infiltration_agents }
		}
		owner = {
			add_modifier = {
				modifier = kl_peerless_infiltration_agents
				years = 20
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = multispecies
						has_ai_personality = hegemonic_imperialists
					}
				}
			}
			modifier = {
				factor = 0
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality = honorbound_warriors
				}
			}
		}
	}
	option = {
		name = keep_leaders.3.b
		trigger = { from = { has_appearance_modding_technology = yes } }
		allow = { event_target:transfer_representative = { NOT = { has_leader_flag = infiltrator_retain_cover } } }
		response_text = keep_leaders.3.b.response
		is_dialog_only = yes
		event_target:transfer_representative = { set_leader_flag = infiltrator_retain_cover }
	}
	option = {
		name = keep_leaders.3.c
		trigger = { from = { has_appearance_modding_technology = yes } }
		allow = { event_target:transfer_representative = { has_leader_flag = infiltrator_retain_cover } }
		response_text = keep_leaders.3.c.response
		is_dialog_only = yes
		event_target:transfer_representative = { remove_leader_flag = infiltrator_retain_cover }
	}
	option = {
		tag = hire_leader
		name = keep_leaders.3.a
		if = {
			limit = { event_target:transfer_representative = { NOT = { has_leader_flag = infiltrator_retain_cover } } }
			custom_tooltip_with_params = {
				description = keep_leaders.3.a.tooltip
				description_parameters = {
					VALUE = "[variable_storage.leader_accumulator]"
				}
			}
		}
		else = {
			custom_tooltip_with_params = {
				description = keep_leaders.3.a.retain.tooltip
				description_parameters = {
					VALUE = "[variable_storage.leader_accumulator]"
				}
			}
		}
		hidden_effect = {
			event_target:transfer_representative = {
				if = {
					limit = {
						from = { has_appearance_modding_technology = yes }
						NOT = { has_leader_flag = infiltrator_retain_cover }
					}
					change_leader_portrait = event_target:potential_owner # swap portrait to non-cover
				}
				take_ownership_of_leader = yes
			}
			event_target:storage_owner = {
				every_owned_leader = {
					limit = {
						NOT = { is_same_value = event_target:transfer_representative }
						is_eligible_transfer_leader_from_storage = yes
					}
					if = {
						limit = { NOT = { has_leader_flag = infiltrator_retain_cover } }
						prepare_to_retain_infiltration_leader = { RETAIN_COVER = no }
					}
					else = {
						prepare_to_retain_infiltration_leader = { RETAIN_COVER = yes }
					}
					take_ownership_of_leader = yes
				}
				try_clean_up_leader_storage = yes
			}
		}
		ai_chance = {
			base = 1
			modifier = {
				factor = 2
				owner = {
					OR = {
						is_authoritarian = yes
						has_valid_civic = civic_meritocracy
					}
				}
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = displacer
						has_ai_personality_behaviour = purger
						has_ai_personality_behaviour = slaver
					}
				}
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality_behaviour = infiltrator
				}
			}
		}
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			owner = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# transfer leaders to storage while the integrated subject country exists
# triggered by on_subject_integrated
# root = country, overlord
# from = country, integrated subject
country_event = {
	id = keep_leaders.5
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		exists = from
		from = {
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader = yes }
			}
		}
	}
	immediate = {
		log = "subject integration: [From.GetRealName] integrated by [This.GetRealName]"
		save_event_target_as = potential_owner # "argument" for create_leader_storage_and_transfer_leaders
		from = { save_event_target_as = former_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
		set_country_flag = keeping_leaders_integration@event_target:storage_owner
		country_event = {
			id = keep_leaders.1 # hooray for reuse!
			scopes = { from = event_target:former_owner }
		}
	}
}

# attempt to copy army transports
# triggered by on_subject_integrated
# root = country, overlord
# from = country, integrated subject
country_event = {
	id = keep_leaders.6
	hide_window = yes
	is_triggered_only = yes
	immediate = {
		save_event_target_as = integrating_country
		from = {
			save_event_target_as = integrated_country
			# flag each army to correspond to a flag set on its transport fleet
			every_owned_army = {
				log = "[This.GetName] owned by [This.Owner.GetName]"
				if = {
					limit = { exists = fleet }
					fleet = {
						if = {
							limit = { NOT = { has_fleet_flag = keep_leaders_army_transport_fleet@this } }
							set_fleet_flag = keep_leaders_army_transport_fleet@this
						}
					}
					set_army_flag = keep_leaders_army_transport_fleet@fleet
				}
			}
			every_controlled_fleet = {
				limit = { is_ship_class = shipclass_transport }
				save_event_target_as = source_fleet
				log = "[source_fleet.GetName] is a transport fleet"
				event_target:integrating_country = {
					create_fleet = {
						effect = {
							if = {
								limit = { event_target:source_fleet = { has_fleet_flag = keep_leader_match_transport_fleet@this } }
								event_target:source_fleet = { remove_fleet_flag = keep_leader_match_transport_fleet@this }
								set_fleet_flag = keep_leader_match_transport_fleet@event_target:source_fleet
							}
							save_event_target_as = target_fleet
							set_name = {
								key = keep_leaders.source_fleet_name
								variable_string = "[source_fleet.GetName]"
							}
							set_owner = event_target:integrating_country
							set_location = event_target:source_fleet
							event_target:source_fleet = {
								every_controlled_ship = {
									save_event_target_as = source_ship
									log = "transport [source_ship.GetName]"
									event_target:target_fleet = {
										event_target:source_fleet.owner = {
											random_owned_army = {
												limit = { has_army_flag = keep_leaders_army_transport_fleet@event_target:source_fleet }
												log = "army [This.GetName] was in fleet [source_fleet.GetName]"
												remove_army_flag = keep_leaders_army_transport_fleet@event_target:source_fleet
												save_event_target_as = source_army
											}
										}
										event_target:source_army = {
											switch = {
												trigger = army_type
												assault_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } } }
												clone_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = clone_army } } }
												cybrex_warform = { prev = { create_army_transport_parameterized = { ARMY_TYPE = cybrex_warform } } }
												gene_warrior_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = gene_warrior_army } } }
												machine_assault_1 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_1 } } }
												machine_assault_2 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_2 } } }
												machine_assault_3 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_3 } } }
												psionic_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = psionic_army } } }
												robotic_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = robotic_army } } }
												shroud_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = shroud_army } } }
												slave_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = slave_army } } }
												titanic_assault_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = titanic_assault_army } } }
												undead_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = undead_army } } }
												xenomorph_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = xenomorph_army } } }
												default = {
													log = "unhandled army type for [This.GetName] owned by [This.Owner.GetRealName] - used assault_army"
													prev = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } }
												}
											}
										}
									}
								}
							}
						}
					}
				}
				delete_fleet = this
			}
		}
	}
}

# triggered by on_leader_species_changed
# root = leader, post-modification
# from = species, pre-modification (if known)
leader_event = {
	id = keep_leaders.7
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		has_leader_flag = force_gender_match_species
		klfis_leader_species_allows_current_gender = no
	}
	immediate = {
		klfis_leader_match_gender_to_species = yes
	}
}

# keep robotic only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.10
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.10 keep robotic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species_lenient = yes
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								klfis_is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep organic only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.11
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.11 keep organic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species = no
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								klfis_is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep same species only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.12
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.12 keep same species only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_same_species = event_target:potential_owner
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: uncybernetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.13
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.13 assimilation (uncyborg priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_genetic_assimilation = yes
				try_apply_psionic_assimilation = yes
				try_apply_uncyborg_assimilation = yes
				# no synthetic assimilation since thematically this is about making leaders fully organic
				try_apply_unmachine_assimilation = yes
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep hive only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.14
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_utopia = yes
		is_regular_hive_empire = yes
	}
	immediate = {
		log = "keep_leaders.14 keep hive only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_hive_species = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep 'em all!
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.15
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			is_regular_empire = yes
			AND = {
				has_battle_thrall_military_leaders_active = yes
				has_valid_civic = civic_machine_servitor
			}
		}
	}
	immediate = {
		log = "keep_leaders.15 keep as many as possible"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_allow_transfer_without_assimilation = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: synthetic/unmachine before biological assimilations
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.16
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.16 assimilation (synthetic/unmachine priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_synthetic_assimilation = yes
				try_apply_unmachine_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = synthetic_assimilation
							has_leader_flag = unmachine_assimilation
						}
					}
					try_apply_cyborg_assimilation = yes
					try_apply_genetic_assimilation = yes
					try_apply_psionic_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: cybernetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.17
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.17 assimilation (cybernetic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_cyborg_assimilation = yes
				try_apply_genetic_assimilation = yes
				try_apply_psionic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = genetic_assimilation
							has_leader_flag = psionic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: psionic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.18
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.18 assimilation (psionic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_psionic_assimilation = yes
				try_apply_cyborg_assimilation = yes
				try_apply_genetic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = psionic_assimilation
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = genetic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: genetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.19
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.19 assimilation (genetic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_genetic_assimilation = yes
				try_apply_cyborg_assimilation = yes
				try_apply_psionic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = genetic_assimilation
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = psionic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# necrophage
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.20
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_necroids = yes
		klfis_is_necrophage_empire = yes
	}
	immediate = {
		log = "keep_leaders.20 necrophage"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				if = {
					limit = { is_robotic_species = no }
					if = {
						limit = {
							OR = {
								is_hive_species = yes
								event_target:potential_owner = {
									OR = {
										has_valid_civic = civic_fanatic_purifiers
										has_policy_flag = purge_allowed
									}
								}
							}
							NAND = {
								has_citizenship_type = {
									country = event_target:potential_owner
									type = citizenship_purge
								}
								has_living_standard = {
									country = event_target:potential_owner
									type = living_standard_none
								}
								has_purge_type = {
									country = event_target:potential_owner
									type = purge_necrophage
								}
							}
						}
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_purge
							cooldown = no
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_none
							cooldown = no
						}
						set_purge_type = {
							country = event_target:potential_owner
							type = purge_necrophage
							cooldown = no
						}
					}
					if = {
						limit = { has_leader_flag = former_gestalt_ruler }
						# if you necrophage them, you lose the secret hive magic
						remove_leader_flag = former_gestalt_ruler
					}
					set_timed_leader_flag = {
						flag = force_gender_match_species
						days = 1
					}
					change_species = event_target:potential_owner
					change_leader_portrait = event_target:potential_owner
					fire_on_action = {
						on_action = on_leader_species_changed
						scopes = { from = event_target:former_species }
					}
					unassign_leader = this
					try_adjust_background = yes
					take_ownership_of_leader = yes
					try_assign_retained_leader_to_former_assignment = yes
				}
				else_if = {
					limit = {
						is_robotic_species = yes
						event_target:potential_owner = { allows_ai_leaders = yes }
						is_bypass_leader_restriction_honored_protectors = yes
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			try_clean_up_leader_storage = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# gatekeeper to potentially keep aquatic stored leaders after being drenched by the Deluge Machine
# triggered by on_planet_transfer
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.21
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_drenched@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) drenched by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = {
				event_target:variable_storage = {
					check_variable = {
						which = leader_aquatic_accumulator
						value > 0
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_aquatic_species = no }
					kill_leader = { show_notification = no }
				}
			}
			from = {
				country_event = {
					id = keep_leaders.1
					scopes = {
						from = prev.fromfrom
						fromfrom = prev
					}
				}
			}
		}
	}
}

# window with options to potentially keep the stored leaders after being cyborgized by the Nanobot Diffuser
# triggered by keep_leaders.31
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.30
	title = keep_leaders.30.title
	desc = keep_leaders.30.desc
	auto_opens = no
	location = this
	show_sound = event_machinery
	picture = GFX_leader_recruitment_bg_planet_destruction # GFX_evt_gray_gooed_planet
	event_window_type = leader_recruit
	notification_event_icon = GFX_message_keep_leaders
	picture_event_data = {
		portrait = event_target:transfer_representative
		room = ethic_spaceship_room
	}
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_synthethic_dawn = yes
		exists = from
		exists = fromfrom
		from = { has_valid_civic = civic_machine_assimilator }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = nanobot_assimilated@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		prepare_for_primitive_planet_transferred = yes
		choose_transfer_representative_leader = yes
	}
	# keep none (nice)
	option = {
		tag = dismiss_leader
		name = keep_leaders.30.b
		custom_tooltip = keep_leaders.30.b.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
	}
	# assimilate: assimilator
	option = {
		tag = hire_leader
		name = keep_leaders.30.a
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			from = {
				OR = {
					has_valid_civic = civic_machine_assimilator
					hidden_trigger = { is_machine_empire = yes }
				}
			}
		}
		allow = { from = { has_valid_civic = civic_machine_assimilator } }
		ai_chance = { base = 20 }
		from = {
			klfis_try_generate_rewards_machine_assimilator = yes
			hidden_effect = {
				country_event = {
					id = keep_leaders.17
					scopes = { from = event_target:storage_owner }
				}
			}
		}
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			from = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being cyborgized by the Nanobot Diffuser
# triggered by on_planet_transfer
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.31
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		has_synthethic_dawn = yes
		exists = from
		exists = fromfrom
		from = { has_valid_civic = civic_machine_assimilator }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = nanobot_assimilated@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) assimilated via nanobots by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = { event_target:variable_storage = { has_stored_leaders_both_robotic_and_organic_non_hive = yes } }
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			planet_event = {
				id = keep_leaders.30
				scopes = {
					from = from
					fromfrom = fromfrom
				}
			}
		}
	}
}

# window with options to potentially keep the stored leaders after being necrophaged by the Necrophagic Spore Diffuser
# triggered by keep_leaders.41
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.40
	title = keep_leaders.40.title
	desc = {
		trigger = {
			exists = from
			NOT = { event_target:storage_owner = { has_country_flag = hive_empire_storage_owner } }
		}
		text = keep_leaders.40.desc
	}
	desc = {
		trigger = {
			exists = from
			event_target:storage_owner = { has_country_flag = hive_empire_storage_owner }
		}
		text = keep_leaders.40.desc.hive
	}
	auto_opens = no
	location = this
	show_sound = event_necrophage
	picture = GFX_leader_recruitment_bg_necrophage # GFX_evt_gray_gooed_planet
	event_window_type = leader_recruit
	notification_event_icon = GFX_message_keep_leaders
	picture_event_data = {
		portrait = event_target:transfer_representative
		room = ethic_spaceship_room
	}
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_necroids = yes
		exists = from
		exists = fromfrom
		from = { klfis_is_necrophage_empire = yes }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_necrophaged@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		prepare_for_primitive_planet_transferred = yes
		choose_transfer_representative_leader = yes
	}
	# keep none (nice)
	option = {
		tag = dismiss_leader
		name = {
			text = keep_leaders.40.b
			trigger = { NOT = { event_target:storage_owner = { has_country_flag = hive_empire_storage_owner } } }
		}
		name = {
			text = keep_leaders.40.b.hive
			trigger = { event_target:storage_owner = { has_country_flag = hive_empire_storage_owner } }
		}
		if = {
			limit = { NOT = { event_target:storage_owner = { has_country_flag = hive_empire_storage_owner } } }
			custom_tooltip = keep_leaders.40.b.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.40.b.hive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = { base = 2 }
	}
	# keep none
	option = {
		name = keep_leaders.40.c
		custom_tooltip = keep_leaders.40.c.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { hidden_trigger = { event_target:storage_owner = { has_country_flag = regular_empire_or_primitive_storage_owner } } }
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				from = { is_xenophile = no }
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				from = { is_pacifist = no }
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = { base = 0 }
	}
	# necrophage
	option = {
		tag = hire_leader
		name = keep_leaders.40.a
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = { has_necroids = yes }
			from = { klfis_is_necrophage_empire = yes }
		}
		allow = {
			custom_tooltip = {
				fail_text = NECROPHAGE_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = CANNOT_NECROPHAGE_MACHINES_NO_X
				event_target:storage_owner = { all_stored_leaders_robotic = no }
			}
		}
		ai_chance = {
			base = 10
			modifier = {
				factor = 2
				from = { has_policy_flag = purge_allowed }
			}
		}
		from = {
			klfis_try_generate_rewards_origin_necrophage = yes
			hidden_effect = {
				country_event = {
					id = keep_leaders.20
					scopes = { from = event_target:storage_owner }
				}
			}
		}
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			from = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being necrophaged by the Necrophagic Spore Diffuser
# triggered by on_planet_transfer
# root = planet (after ownership change)
# from = country, colossus'd
planet_event = {
	id = keep_leaders.41
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_necroids = yes
		exists = from
		exists = fromfrom
		from = { klfis_is_necrophage_empire = yes }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_necrophaged@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) necrophaged by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = {
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			planet_event = {
				id = keep_leaders.40
				scopes = {
					from = from
					fromfrom = fromfrom
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being made believers by the Divine Enforcer
# triggered by on_planet_transfer
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.51
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = divinely_enforced@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) had divine belief enforced by [From.GetRealName]"
		if = {
			limit = { event_target:variable_storage = { has_any_stored_leaders_organic_non_hive = yes } }
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_eligible_transfer_leader = yes }
					if = {
						limit = {
							OR = {
								is_robotic_species = yes
								is_hive_species = yes
							}
						}
						kill_leader = { show_notification = no }
					}
					else_if = {
						limit = {
							NOR = {
								has_leader_flag = legendary_leader
								has_leader_flag = renowned_leader
							}
						}
						change_background_ethic = ethic_spiritualist
					}
				}
			}
			from = {
				country_event = {
					id = keep_leaders.1
					scopes = {
						from = prev.fromfrom
						fromfrom = prev
					}
				}
			}
		}
	}
}

# this event is intended to run after all other on_planet_transfer handlers and deletes the container country if it wasn't flagged as handled
# triggered by on_planet_transfer
# root = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.99
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			NOT = { has_country_flag = colossus_transfer_handled@prev }
			# if you are a developer, have your handler set the colossus_transfer_handled@planet to preserve the container country beyond the "on_planet_transfer" on_action
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		from = { save_event_target_as = potential_owner }
		random_country = {
			limit = { has_country_flag = former_owner@fromfrom }
			try_clean_up_leader_storage = yes
		}
	}
}

# triggered by on_leader_death_notify
# root = country
# from = leader
country_event = {
	id = keep_leaders.100
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		exists = from
		from = { has_leader_flag = former_gestalt_ruler }
		any_owned_pop_species = { is_same_species = from }
	}
	immediate = {
		log = "keep_leaders.100 former gestalt leader [From.GetName] death"
		# event_target:former_owner_shell@from = {
			create_leader = {
				name = random
				class = random
				species = from
				effect = { save_event_target_as = age_proxy }
			}
			clone_leader = {
				target = from
				effect = {
					set_leader_flag = former_gestalt_ruler_clone
					copy_flags_and_variables_from = from
					add_experience = from.trigger:has_experience # doesn't get copied implicitly when cloned
					set_years_served = from
					set_age = event_target:age_proxy.trigger:leader_age
					event_target:age_proxy = { kill_leader = { show_notification = no } }
					save_event_target_as = former_gestalt_ruler
					exile_leader_as = exiled_former_gestalt_ruler
				}
			}
		# }
		country_event = {
			id = keep_leaders.101
			scopes = { from = event_target:former_gestalt_ruler }
			days = 30
			random = 60
		}
	}
}

# the "dead" gestalt leader re-emerges 1-3 months after keep_leaders.100
# root = country
# from = the exiled leader
country_event = {
	id = keep_leaders.101
	is_triggered_only = yes
	title = keep_leaders.101.title
	desc = {
		text = keep_leaders.101.desc
		trigger = {
			is_hive_empire = no
			is_machine_empire = no
		}
	}
	desc = {
		text = keep_leaders.101.desc.hive
		trigger = { is_hive_empire = yes }
	}
	desc = {
		text = keep_leaders.101.desc.mach
		trigger = { is_machine_empire = yes }
	}
	auto_opens = no
	location = capital_scope
	show_sound = {
		trigger = { from = { is_robotic_species = no } }
		sound = event_evolution_mastery
	}
	show_sound = {
		trigger = { from = { is_robotic_species = yes } }
		sound = event_synthetic_evolution
	}
	# picture = {
	# 	trigger = { from = { is_robotic_species = no } }
	# 	picture = GFX_evt_hive_mind
	# }
	# picture = {
	# 	trigger = { from = { is_robotic_species = yes } }
	# 	picture = GFX_evt_machine_sapience
	# }
	picture = GFX_leader_recruitment_bg_renowned
	event_window_type = leader_recruit
	notification_event_icon = GFX_message_keep_leaders
	picture_event_data = {
		portrait = event_target:transfer_representative
		room = ethic_spaceship_room
	}
	trigger = {
		exists = from
		from = { has_leader_flag = former_gestalt_ruler_clone }
		any_owned_pop_species = { is_same_species = from }
	}
	immediate = {
		log = "keep_leaders.101 former gestalt leader [From.GetFirstName] respawned"
		from = {
			set_leader_flag = is_in_recruit_window
			save_event_target_as = transfer_representative
		}
	}
	option = {
		tag = dismiss_leader
		name = keep_leaders.101.b
		custom_tooltip = keep_leaders.101.b.tooltip
		hidden_effect = {
			event_target:transfer_representative = {
				klfis_unexile_leader = yes
				recruitable = no
				recruitable = yes
			}
		}
	}
	# TODO: some flavor options to ask the leader about stuff?
	option = {
		tag = hire_leader
		name = INCREDIBLE
		custom_tooltip = keep_leaders.101.a.tooltip
		hidden_effect = {
			hire_event_leader_effect = { LEADER = transfer_representative }
			# recalculate former ruler country bonuses
			country_event = {
				id = keep_leaders_bonus_traits.20
			}
		}
	}
	after = {
		hidden_effect = {
			event_target:transfer_representative = {
				remove_leader_flag = is_in_recruit_window
				if = {
					limit = { has_leader_flag = former_gestalt_ruler_clone }
					remove_leader_flag = former_gestalt_ruler_clone
				}
			}
		}
	}
}

# triggered by on_leader_death and on_leader_fired (not currently active)
# attempt to clean up former_owner_shells when the relevant leaders die/get fired,
# but not if there is another leader using the same shell
# root = country
# from = leader
country_event = {
	id = keep_leaders.110
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		exists = from
		from = {
			OR = {
				has_leader_flag = former_ruler
				has_leader_flag = former_heir
			}
		}
		exists = event_target:former_owner_shell@from
	}
	immediate = {
		event_target:former_owner_shell@from = {
			# pretty sure things will get weird if I try to use a dynamic event_target as a suffix to another dynamic event_target - so save it locally
			save_event_target_as = former_owner_shell
		}
		if = {
			limit = {
				event_target:former_owner_shell = { NOT = { any_owned_leader = { has_leader_flag = former_gestalt_ruler_clone } } }
				# I doubt the leaders somehow got split up, but just in case check all the countries
				count_country = {
					count = all
					limit = {
						NOR = {
							any_owned_leader = {
								NOT = { is_same_value = from }
								has_leader_flag = former_owner_shell@event_target:former_owner_shell
							}
							any_pool_leader = {
								NOT = { is_same_value = from }
								has_leader_flag = former_owner_shell@event_target:former_owner_shell
							}
						}
					}
				}
			}
			event_target:former_owner_shell = { destroy_country = yes }
		}
	}
}

# triggered by on_leader_owner_changed
# gestalts gain the warform trait for their node upon gaining the warform
leader_event = {
	id = keep_leaders.164
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_trait = leader_trait_admiral_warform
		owner = { is_gestalt = yes }
	}
	immediate = {
		owner = {
			random_owned_leader = {
				limit = { is_councilor_type = councilor_gestalt_admiral }
				add_trait = leader_trait_admiral_warform_node
			}
		}
	}
}

# triggered by on_leader_owner_changed
# gestalts gain the caretaker trait for their node upon gaining the caretaker
leader_event = {
	id = keep_leaders.246
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_trait = leader_trait_govenor_caretaker
		owner = { is_gestalt = yes }
	}
	immediate = {
		owner = {
			random_owned_leader = {
				limit = { is_councilor_type = councilor_gestalt_governor }
				add_trait = leader_trait_govenor_caretaker_node
			}
		}
	}
}

# triggered by on_leader_owner_changed
# remove the memory value lockout - the leader can contribute to a new vault
# ideally PDX would use a dynamic flag memory_vault_contributed@owner so it would be possible to identify whose vault(s) to which the leader has contributed
leader_event = {
	id = keep_leaders.2044
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = { has_leader_flag = memory_vault_contributed }
	immediate = { remove_leader_flag = memory_vault_contributed }
}

# triggered by on_leader_owner_changed
# memory vaults empires gain a charge for every qualifying leader
leader_event = {
	id = keep_leaders.2045
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		NOT = { has_leader_flag = memory_vault_contributed }
		owner = { is_memory_vault_empire = yes }
	}
	immediate = {
		if = {
			limit = {
				OR = {
					has_leader_flag = renowned_leader
					has_leader_flag = legendary_leader
					has_skill >= 8
				}
			}
			owner = {
				random_owned_planet = {
					limit = { is_variable_set = paragon_memory_vault }
					change_variable = {
						which = paragon_memory_vault
						value = 1
					}
				}
			}
			set_leader_flag = memory_vault_contributed
		}
	}
}
