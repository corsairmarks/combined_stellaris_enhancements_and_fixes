namespace = keep_leaders

# TODO: verify whether I need phobe/phage checks here at all - assimilation options probably need a check that sees whether any leaders can be assimilated (new variable)

# triggered by keep_leaders.2, keep_leaders.5, keep_leaders.21, keep_leaders.51
# window with options to potentially keep the stored leaders from integration/primitive conquest/colossus weapon
# root = country, overlord
# from = country, integrated subject or conquered/colossus'd primitives
# fromfrom = planet, primitive world (if available)
country_event = {
	id = keep_leaders.1
	picture = {
		picture = GFX_evt_intelligence_report
		trigger = {
			OR = {
				has_country_flag = keeping_leaders_conquest@from
				has_country_flag = keeping_leaders_integration@from
			}
		}
	}
	picture = {
		picture = GFX_evt_planet_beam
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			from = {
				has_country_flag = colossus_transfer@fromfrom
				OR = {
					has_country_flag = orbitally_drenched@fromfrom
					has_country_flag = divinely_enforced@fromfrom
				}
			}
		}
	}
	picture = {
		picture = GFX_evt_death_from_above
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			from = {
				has_country_flag = colossus_transfer@fromfrom
				NOR = {
					has_country_flag = orbitally_drenched@fromfrom
					has_country_flag = divinely_enforced@fromfrom
					has_country_flag = nanobot_assimilated@fromfrom
					has_country_flag = orbitally_necrophaged@fromfrom
				}
			}
		}
	}
	title = keep_leaders.1.title.scripted_loc
	desc = {
		trigger = { has_country_flag = keeping_leaders_conquest@from }
		show_sound = event_vote
		text = keep_leaders.1.desc.conquest
	}
	desc = {
		trigger = { has_country_flag = keeping_leaders_integration@from }
		show_sound = event_vote
		text = keep_leaders.1.desc.integration
	}
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			from = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = orbitally_drenched@fromfrom
			}
		}
		show_sound = aqu_wep_colossus_planet_hit
		text = keep_leaders.1.desc.planet_killer_deluge
	}
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			from = {
				has_country_flag = colossus_transfer@fromfrom
				has_country_flag = divinely_enforced@fromfrom
			}
		}
		show_sound = event_mystic_reveal
		text = keep_leaders.1.desc.planet_killer_godray
	}
	desc = {
		trigger = {
			exists = fromfrom
			fromfrom = { is_scope_type = planet }
			from = {
				has_country_flag = colossus_transfer@fromfrom
				NOR = {
					has_country_flag = orbitally_drenched@fromfrom
					has_country_flag = divinely_enforced@fromfrom
					has_country_flag = nanobot_assimilated@fromfrom
					has_country_flag = orbitally_necrophaged@fromfrom
				}
			}
		}
		show_sound = event_red_alert
		text = keep_leaders.1.desc.planet_killer_generic
	}
	is_triggered_only = yes
	trigger = {
		exists = from
		any_country = {
			is_country_type = neutral_faction
			has_country_flag = former_owner@from
			any_owned_leader = {
				has_leader_flag = former_owner@from
				has_leader_flag = potential_owner@prevprev
			}
		}
	}
	immediate = {
		log = "country [This.GetRealName] retaining leaders from [From.GetRealName]"
		# "argument" for create_leader_storage_and_transfer_leaders
		save_event_target_as = potential_owner
		from = {
			save_event_target_as = former_owner
			owner_species = { save_event_target_as = original_species }
			fromfrom = { save_event_target_as = conquered_planet } # "argument" for localistation
		}
		# acquire leader and variable storage
		random_country = {
			limit = {
				is_country_type = neutral_faction
				has_country_flag = former_owner@from
			}
			save_event_target_as = storage_owner
			save_event_target_as = variable_storage
		}
	}
	# keep none
	option = {
		name = keep_leaders.1.a
		custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { is_homicidal = no }
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.serv.fail_text
				NAND = {
					has_valid_civic = civic_machine_servitor
					event_target:storage_owner = {
						any_owned_leader = {
							is_eligible_transfer_leader_from_storage = yes
							is_robotic_species = no
							is_hive_species = no
						}
					}
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0.5
				is_necrophage_empire = yes
			}
		}
	}
	option = {
		name = keep_leaders.1.a.pur
		custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_fanatic_purifiers
		}
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_not_same_species_accumulator
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0.5
				is_necrophage_empire = yes
			}
			modifier = {
				factor = 3
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
		}
	}
	option = {
		name = keep_leaders.1.a.swarm
		custom_tooltip = keep_leaders.1.a.swarm.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_hive_devouring_swarm
		}
		add_resource = {
			society_research = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_organic_accumulator
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 20
				has_valid_civic = civic_hive_devouring_swarm
			}
		}
	}
	option = {
		name = keep_leaders.1.a.term
		custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_terminator
		}
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_organic_accumulator
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 5
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
	}
	# keep none (nice)
	option = {
		name = keep_leaders.1.b
		custom_tooltip = keep_leaders.1.b.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { is_regular_empire = yes }
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { all_stored_leaders_same_species = yes }
				}
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_necrophage_empire = yes
			}
			modifier = {
				factor = 100
				has_valid_civic = civic_inwards_perfection
			}
		}
	}
	option = {
		name = keep_leaders.1.b.serv
		custom_tooltip = keep_leaders.1.b.serv.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_servitor
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = { factor = 1 }
	}
	option = {
		name = keep_leaders.1.b.gest.exclusive
		custom_tooltip = keep_leaders.1.b.gest.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use triggers so that these will be translated into icons
			OR = {
				has_authority = auth_hive_mind
				has_authority = auth_machine_intelligence
			}
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_machine_servitor
					has_valid_civic = civic_hive_devouring_swarm
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.term.fail_text
				if = {
					limit = { has_valid_civic = civic_machine_terminator }
					event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.mach.fail_text
				if = {
					limit = {
						is_machine_empire = yes
						NOT = { has_valid_civic = civic_machine_servitor }
					}
					event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.b.hive.fail_text
				if = {
					limit = { is_regular_hive_empire = yes }
					event_target:storage_owner = { all_stored_leaders_hive = yes }
				}
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
	}
	# keep robotic only - non-assimilation
	option = {
		name = keep_leaders.1.c
		custom_tooltip = keep_leaders.1.c.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			is_regular_empire = yes
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_fanatic_purifiers
					has_active_tradition = tr_cybernetics_transubstantiation_synthesis
				}
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 0
				is_spiritualist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.term
		custom_tooltip = keep_leaders.1.c.term.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_terminator
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				NOT = { has_valid_civic = civic_machine_terminator }
			}
		}
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_organic_accumulator
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.mach
		custom_tooltip = keep_leaders.1.c.mach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use a trigger so that this will be translated into an icon
			has_authority = auth_machine_intelligence
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_machine_assimilator
					has_valid_civic = civic_machine_terminator
				}
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.serv.fail_text
				NOT = { has_valid_civic = civic_machine_servitor }
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				is_machine_empire = yes
				NOR = {
					has_valid_civic = civic_machine_assimilator
					has_valid_civic = civic_machine_servitor
					has_valid_civic = civic_machine_terminator
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.mach.exclusive
		custom_tooltip = keep_leaders.1.c.mach.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use a trigger so that this will be translated into an icon
			has_authority = auth_machine_intelligence
			hidden_trigger = {
				NOT = { has_valid_civic = civic_machine_assimilator }
				event_target:storage_owner = { all_stored_leaders_robotic_strict = yes }
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				is_machine_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.cyb
		icon = {
			icon = GFX_tr_cybernetics_transubstantiation_synthesis
			text = keep_leaders.1.cyb.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.c.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_active_tradition = tr_cybernetics_transubstantiation_synthesis
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_cyborg_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species_lenient = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.cyb
		custom_tooltip = keep_leaders.1.c.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_assimilator
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_cyborg_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species_lenient = yes
					}
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.assim.exclusive
		custom_tooltip = keep_leaders.1.c.assim.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_assimilator
			hidden_trigger = { event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes } }
		}
		allow = {
			OR = {
				has_country_flag = cyborg_empire
				has_valid_civic = civic_machine_assimilator
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 5
				has_valid_civic = civic_machine_assimilator
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# keep robotic only (nice) - non-assimilation
	option = {
		name = keep_leaders.1.d
		custom_tooltip = keep_leaders.1.d.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_materialist = yes
			}
			modifier = {
				factor = 0
				is_spiritualist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.d.serv
		custom_tooltip = keep_leaders.1.d.serv.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_servitor
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		ai_chance = { factor = 4 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# keep organic only - non-assimilation
	option = {
		name = {
			text = keep_leaders.1.e
			trigger = { is_spiritualist = no }
		}
		name = {
			text = keep_leaders.1.e.spir
			trigger = { is_spiritualist = yes }
		}
		custom_tooltip = keep_leaders.1.e.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				has_policy_flag = robots_outlawed
				has_policy_flag = ai_outlawed
				has_policy_flag = ai_servitude
			}
			hidden_trigger = {
				NOR = {
					has_country_flag = synthetic_empire
					has_valid_civic = civic_fanatic_purifiers
				}
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				NOT = { has_valid_civic = civic_fanatic_purifiers }
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_spiritualist = yes
			}
			modifier = {
				factor = 0
				is_materialist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.e.ai
		custom_tooltip = keep_leaders.1.e.ai.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			allows_ai_leaders = yes
			hidden_trigger = {
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				NOT = { has_valid_civic = civic_fanatic_purifiers }
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_spiritualist = yes
			}
			modifier = {
				factor = 0
				is_materialist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.e.serv
		custom_tooltip = keep_leaders.1.e.serv.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_servitor
			hidden_trigger = {
				has_battle_thrall_military_leaders_active = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 3
				event_target:storage_owner = {
					any_owned_leader = {
						is_robotic_species = no
						is_hive_species = no
						klfis_has_species_trait_with_leader_trait = yes
					}
				}
			}
			modifier = {
				factor = 0
				event_target:storage_owner = {
					NOT = {
						any_owned_leader = {
							is_robotic_species = no
							is_hive_species = no
							klfis_has_species_trait_with_leader_trait = yes
						}
					}
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.e.serv.exclusive
		custom_tooltip = keep_leaders.1.e.serv.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_servitor
			hidden_trigger = {
				has_battle_thrall_military_leaders_active = yes
				event_target:storage_owner = {
					count_owned_leader = {
						count = all
						limit = {
							OR = {
								is_eligible_transfer_leader_from_storage = no
								AND = {
									is_robotic_species = no
									is_hive_species = no
								}
							}
						}
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 3
				event_target:storage_owner = {
					any_owned_leader = {
						is_robotic_species = no
						is_hive_species = no
						klfis_has_species_trait_with_leader_trait = yes
					}
				}
			}
			modifier = {
				factor = 0
				event_target:storage_owner = {
					NOT = {
						any_owned_leader = {
							is_robotic_species = no
							is_hive_species = no
							klfis_has_species_trait_with_leader_trait = yes
						}
					}
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# same species only
	option = {
		name = keep_leaders.1.g
		custom_tooltip = keep_leaders.1.g.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_same_species = event_target:potential_owner
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_fanatic_purifiers
			}
			modifier = {
				factor = 0.5
				has_origin = origin_necrophage
				has_trait = trait_necrophage
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.g.pur
		custom_tooltip = keep_leaders.1.g.pur.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_fanatic_purifiers
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_same_species = event_target:potential_owner
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 2
				has_valid_civic = civic_fanatic_purifiers
			}
			modifier = {
				factor = 0.5
				has_origin = origin_necrophage
				has_trait = trait_necrophage
			}
		}
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_not_same_species_accumulator
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# same species only (nice)
	option = {
		name = keep_leaders.1.h
		custom_tooltip = keep_leaders.1.h.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_same_species = event_target:potential_owner
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 0.5
				is_xenophobe = yes
			}
			modifier = {
				factor = 4
				is_necrophage_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# hive keep hive only
	option = {
		name = {
			text = keep_leaders.1.i.hive
			trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_hive_species = no
					}
				}
			}
		}
		name = {
			text = keep_leaders.1.i.hive.exclusive
			trigger = { event_target:storage_owner = { all_stored_leaders_hive = yes } }
		}
		if = {
			limit = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_hive_species = no
					}
				}
			}
			custom_tooltip = keep_leaders.1.i.hive.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.i.hive.exclusive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_hive_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_authority = auth_hive_mind
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_hive_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
			}
		}
		ai_chance = { factor = 5 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.14
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# try to keep as many as possible
	option = {
		name = {
			text = keep_leaders.1.j
			trigger = {
				NOR = {
					has_valid_civic = civic_fanatic_purifiers
					has_valid_civic = civic_machine_servitor
				}
			}
		}
		name = {
			text = keep_leaders.1.j.pur
			trigger = { has_valid_civic = civic_fanatic_purifiers }
		}
		name = {
			text = keep_leaders.1.j.serv
			trigger = { has_valid_civic = civic_machine_servitor }
		}
		if = {
			limit = {
				has_battle_thrall_military_leaders_active = yes
				has_valid_civic = civic_machine_servitor
			}
			custom_tooltip = keep_leaders.1.j.serv.tooltip
		}
		else_if = {
			limit = { NOT = { has_valid_civic = civic_fanatic_purifiers } }
			custom_tooltip = keep_leaders.1.j.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.j.pur.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				is_regular_empire = yes
				AND = {
					# uses has_civic instead of has_valid_civic so that this will be translated into an icon
					has_civic = civic_machine_servitor
					hidden_trigger = {
						has_battle_thrall_military_leaders_active = yes
						event_target:storage_owner = {
							any_owned_leader = {
								is_eligible_transfer_leader_from_storage = yes
								is_robotic_species = no
								is_hive_species = no
							}
							any_owned_leader = {
								is_eligible_transfer_leader_from_storage = yes
								is_robotic_species = yes
							}
						}
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = {
						is_necrophage_empire = yes
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
							}
						}
					}
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = {
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
							}
						}
						is_xenophobe = yes
					}
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { all_stored_leaders_same_species = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.j.fail_text
				event_target:variable_storage = {
					check_variable = {
						which = leader_transferable_accumulator
						value > 0
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_pacifist = yes
			}
			modifier = {
				factor = 2
				is_xenophile = yes
			}
			modifier = {
				factor = 2
				allows_ai_leaders = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_inwards_perfection
			}
			modifier = {
				factor = 20
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { all_stored_leaders_same_species = yes }
			}
			modifier = {
				factor = 10
				has_battle_thrall_military_leaders_active = yes
				has_valid_civic = civic_machine_servitor
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.15
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: hive
	option = {
		name = keep_leaders.1.k.hive
		icon = {
			icon = GFX_ap_engineered_evolution
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.hive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_engineered_evolution
			hidden_trigger = {
				is_hive_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_hive_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_genetic_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				is_potential_for_genetic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_hive_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.19
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: unhive
	option = {
		name = keep_leaders.1.k.unhive
		icon = {
			icon = GFX_ap_engineered_evolution
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unhive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_engineered_evolution
			hidden_trigger = {
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_unhive_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_genetic_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				is_potential_for_genetic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unhive_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unhive_assimilation_species } }
				}
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.19
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: psionic
	option = {
		name = keep_leaders.1.k.psi
		icon = {
			icon = GFX_ap_mind_over_matter
			text = keep_leaders.1.k.psi.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.psi.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				has_ascension_perk = ap_mind_over_matter
				has_origin = origin_shroudwalker_apprentice
			}
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_psionic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_psionic_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.psionic.fail_text
				is_potential_for_psionic_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_psionic_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_psionic_assimilation_species } }
				}
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.18
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: cybernetic (non-hive)
	option = {
		name = keep_leaders.1.k.cyb
		icon = {
			icon = GFX_ap_the_flesh_is_weak
			text = keep_leaders.1.k.cyb.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_the_flesh_is_weak
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_regular_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_cyborg_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb.fail_text
				is_potential_for_cyborg_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_regular_cyborg_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_regular_cyborg_assimilation_species } }
				}
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: cybernetic (hive)
	option = {
		name = keep_leaders.1.k.cyb.hive
		icon = {
			icon = GFX_ap_organo_machine_interfacing
			text = keep_leaders.1.k.cyb.hive.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.cyb.hive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_organo_machine_interfacing
			hidden_trigger = {
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_hive_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_cyborg_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb.fail_text
				is_potential_for_cyborg_assimilation_country = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_hive_cyborg_assimilation_species } }
				}
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: synthetic
	option = {
		name = keep_leaders.1.k.synth
		icon = {
			icon = GFX_ap_synthetic_evolution
			text = keep_leaders.1.k.synth.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.synth.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_synthetic_evolution
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_regular_synthetic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_synthetic_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth1.fail_text
				has_active_tradition = tr_synthetics_synthetic_age
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth2.fail_text
				has_country_flag = synth_assimilation
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_regular_synthetic_assimilation_species } }
				}
			}
		}
		ai_chance = {
			factor = 10
			modifier = {
				factor = 0.5
				is_xenophile = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: synthetic (machine)
	option = {
		name = keep_leaders.1.k.synth.mach
		icon = {
			icon = GFX_ap_synthetic_age
			text = keep_leaders.1.k.synth.mach.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.synth.mach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_ascension_perk = ap_synthetic_age
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_machine_synthetic_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_synthetic_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth.mach.fail_text
				has_active_tradition = tr_synthetics_adopt_machine
			}
		}
		if = {
			limit = { has_valid_civic = civic_machine_terminator }
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_organic_accumulator
			}
		}
		ai_chance = { factor = 10 }
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: assimilator
	option = {
		name = keep_leaders.1.k.assim
		custom_tooltip = keep_leaders.1.k.assim.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# uses has_civic instead of has_valid_civic so that this will be translated into an icon
			has_civic = civic_machine_assimilator
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_machine_cyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_cyborg_possible_accumulator
					value > 0
				}
			}
		}
		ai_chance = { factor = 20 }
		if = {
			limit = { NOT = { has_active_tradition = tr_cybernetics_assimilator_adopt } }
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				society_research = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_organic_non_cyborg_accumulator
			}
		}
		else = {
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				society_research = @keep_leaders_civic_reward_base
				engineering_research = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_organic_non_cyborg_accumulator_double
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: unmachine
	option = {
		name = keep_leaders.1.k.unmach
		icon = {
			icon = GFX_icon_tech_sapient_ai_alternate
			text = keep_leaders.1.k.unmach.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unmach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_technology = tech_sapient_ai
			hidden_trigger = {
				has_synthethic_dawn = yes
				has_deassimilate_machines_active = yes
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_unmachine_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_unmachine_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_policy_flag = robots_allowed
					is_robot_empire = yes
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				allows_ai_leaders = yes
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				is_necrophage_empire = no
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_unmachine_assimilation_species } }
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: uncyborg
	option = {
		name = {
			text = keep_leaders.1.k.uncyb
			trigger = { is_valid_organic_zealots = no }
		}
		name = {
			text = keep_leaders.1.k.uncyb.zeal
			trigger = { is_valid_organic_zealots = yes }
		}
		icon = {
			icon = GFX_icon_tech_gene_banks_alternate
			text = keep_leaders.1.k.uncyb.icon.tooltip
		}
		if = {
			limit = { is_valid_organic_zealots = no }
			custom_tooltip = keep_leaders.1.k.uncyb.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.uncyb.zeal.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]" # no special count, it's in addition to existing transformations
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_technology = tech_gene_tailoring
			has_technology = tech_gene_banks
			hidden_trigger = {
				OR = {
					has_synthethic_dawn = yes
					has_utopia = yes
				}
				has_civic_organic_zealots_active = yes
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_potential_for_uncyborg_assimilation_species = yes
					}
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = ASSIMILATION_NONE_ELIGIBLE_NO_X
				check_variable = {
					which = leader_assimilatable_uncyborg_possible_accumulator
					value > 0
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_uncyborg_assimilation_species } }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { any_stored_leaders_eligible_to_transfer_main_species_leader_restricted = { TRIGGER = is_potential_for_uncyborg_assimilation_species } }
				}
			}
		}
		ai_chance = {
			base = 0
			modifier = {
				add = 50
				is_valid_organic_zealots = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.13
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# necrophage (kinda like assimilation in terms of the outcome)
	option = {
		name = keep_leaders.1.k.necro
		if = {
			limit = { is_hive_empire = no }
			custom_tooltip = keep_leaders.1.k.necro.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.necro.hive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = { has_necroids = yes }
			has_origin = origin_necrophage
			hidden_trigger = { has_trait = trait_necrophage }
		}
		allow = {
			custom_tooltip = {
				fail_text = NECROPHAGE_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = CANNOT_NECROPHAGE_MACHINES_NO_X
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
					}
				}
			}
		}
		ai_chance = {
			factor = 10
			modifier = {
				factor = 2
				has_policy_flag = purge_allowed
			}
		}
		# necrophage unity
		if = {
			limit = {
				OR = {
					has_active_tradition = tr_harmony_unity_of_self
					has_active_tradition = tr_synchronicity_unity_of_mind
				}
			}
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_necrophagable_accumulator
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.20
				scopes = { from = event_target:storage_owner }
			}
		}
	}
}

# triggered by on_planet_attackers_win (same on_action as primitive planet conquest action.14)
# root = country, leader attacker
# from = country, planet owner
# fromfrom = planet
country_event = {
	id = keep_leaders.2
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		any_playable_country = { is_country = prev }
		exists = from
		from = {
			is_country_type = primitive
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader_class = yes }
			}
		}
	}
	immediate = {
		log = "primitive conquest: [FromFrom.GetName] ([From.GetRealName]) conquered by [This.GetRealName]"
		set_country_flag = keeping_leaders_conquest@from
		save_event_target_as = potential_owner # "argument" for create_leader_storage_and_transfer_leaders
		from = { save_event_target_as = former_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
		country_event = {
			id = keep_leaders.1 # hooray for reuse!
			scopes = {
				from = from
				fromfrom = fromfrom
			}
		}
	}
}

# window with options to potentially keep the stored leaders from infiltration
# triggered by on_planet_transfer
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.3
	title = keep_leaders.3.title
	desc = keep_leaders.3.desc
	picture = GFX_evt_diplomatic_visit
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		has_modifier = infiltration_happiness
		exists = from
		exists = fromfrom
		fromfrom = { is_country_type = primitive }
	}
	immediate = {
		log = "primitive infiltration: [This.GetName] ([FromFrom.GetRealName]) infiltrated by [From.GetRealName]"
		from = { set_country_flag = keeping_leaders_infiltration@fromfrom }
		fromfrom = {
			save_event_target_as = former_owner # "argument" for localistation and create_leader_storage_and_transfer_leaders
			owner_species = { save_event_target_as = original_species } # "argument" for localistation
		}
		from = { save_event_target_as = potential_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
	}
	option = {
		name = keep_leaders.3.a
		custom_tooltip_with_params = {
			description = keep_leaders.3.a.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_accumulator]"
			}
		}
		hidden_effect = {
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_eligible_transfer_leader_from_storage = yes }
					set_leader_flag = infiltrator_retained
					set_timed_leader_flag = {
						flag = force_gender_match_species
						days = 1
					}
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					fire_on_action = {
						on_action = on_leader_species_changed
						scopes = { from = event_target:original_species }
					}
					remove_leader_flag = infiltrator_retained
				}
				destroy_country = yes
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = { is_xenophobe = yes }
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = displacer
						has_ai_personality_behaviour = slaver
					}
				}
			}
		}
	}
	option = {
		name = keep_leaders.3.b
		custom_tooltip_with_params = {
			description = keep_leaders.3.b.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_accumulator]"
			}
		}
		hidden_effect = {
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_eligible_transfer_leader_from_storage = yes }
					set_leader_flag = infiltrator_retained_cover
					set_timed_leader_flag = {
						flag = force_gender_match_species
						days = 1
					}
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					change_leader_portrait = event_target:original_species
					fire_on_action = {
						on_action = on_leader_species_changed
						scopes = { from = event_target:original_species }
					}
					# make sure we get the correct species portrait even if the gender was swapped via clone
					if = {
						limit = { has_leader_flag = leader_replaced_by_clone@last_created_leader }
						last_created_leader = { change_leader_portrait = event_target:original_species }
					}
					remove_leader_flag = infiltrator_retained_cover
				}
				destroy_country = yes
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = { is_authoritarian = yes }
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality_behaviour = infiltrator
				}
			}
		}
	}
	option = {
		name = keep_leaders.3.c
		owner = {
			add_modifier = {
				modifier = kl_peerless_infiltration_agents
				years = 20
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = multispecies
						has_ai_personality = hegemonic_imperialists
					}
				}
			}
			modifier = {
				factor = 0
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality = honorbound_warriors
				}
			}
		}
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			owner = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# transfer leaders to storage while the integrated subject country exists
# triggered by on_subject_integrated
# root = country, overlord
# from = country, integrated subject
country_event = {
	id = keep_leaders.5
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		exists = from
		from = {
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader_class = yes }
			}
		}
	}
	immediate = {
		log = "subject integration: [From.GetRealName] integrated by [This.GetRealName]"
		set_country_flag = keeping_leaders_integration@from
		save_event_target_as = potential_owner # "argument" for create_leader_storage_and_transfer_leaders
		from = { save_event_target_as = former_owner } # "argument" for create_leader_storage_and_transfer_leaders
		create_leader_storage_and_transfer_leaders = yes
		country_event = {
			id = keep_leaders.1 # hooray for reuse!
			scopes = { from = from }
		}
	}
}

# attempt to copy army transports
# triggered by on_subject_integrated
# root = country, overlord
# from = country, integrated subject
country_event = {
	id = keep_leaders.6
	hide_window = yes
	is_triggered_only = yes
	immediate = {
		save_event_target_as = integrating_country
		from = {
			save_event_target_as = integrated_country
			# flag each army to correspond to a flag set on its transport fleet
			every_owned_army = {
				log = "[This.GetName] owned by [This.Owner.GetName]"
				if = {
					limit = { exists = fleet }
					fleet = {
						if = {
							limit = { NOT = { has_fleet_flag = keep_leaders_army_transport_fleet@this } }
							set_fleet_flag = keep_leaders_army_transport_fleet@this
						}
					}
					set_army_flag = keep_leaders_army_transport_fleet@fleet
				}
			}
			every_controlled_fleet = {
				limit = { is_ship_class = shipclass_transport }
				save_event_target_as = source_fleet
				log = "[source_fleet.GetName] is a transport fleet"
				event_target:integrating_country = {
					create_fleet = {
						effect = {
							if = {
								limit = { event_target:source_fleet = { has_fleet_flag = keep_leader_match_transport_fleet@this } }
								event_target:source_fleet = { remove_fleet_flag = keep_leader_match_transport_fleet@this }
								set_fleet_flag = keep_leader_match_transport_fleet@event_target:source_fleet
							}
							save_event_target_as = target_fleet
							set_name = {
								key = keep_leaders.source_fleet_name
								variable_string = "source_fleet.GetName"
							}
							set_owner = event_target:integrating_country
							set_location = event_target:source_fleet
							event_target:source_fleet = {
								every_controlled_ship = {
									save_event_target_as = source_ship
									log = "transport [source_ship.GetName]"
									event_target:target_fleet = {
										event_target:source_fleet.owner = {
											random_owned_army = {
												limit = { has_army_flag = keep_leaders_army_transport_fleet@event_target:source_fleet }
												log = "army [This.GetName] was in fleet [source_fleet.GetName]"
												remove_army_flag = keep_leaders_army_transport_fleet@event_target:source_fleet
												save_event_target_as = source_army
											}
										}
										event_target:source_army = {
											switch = {
												trigger = army_type
												assault_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } } }
												clone_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = clone_army } } }
												cybrex_warform = { prev = { create_army_transport_parameterized = { ARMY_TYPE = cybrex_warform } } }
												gene_warrior_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = gene_warrior_army } } }
												machine_assault_1 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_1 } } }
												machine_assault_2 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_2 } } }
												machine_assault_3 = { prev = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_3 } } }
												psionic_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = psionic_army } } }
												robotic_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = robotic_army } } }
												shroud_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = shroud_army } } }
												slave_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = slave_army } } }
												titanic_assault_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = titanic_assault_army } } }
												undead_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = undead_army } } }
												xenomorph_army = { prev = { create_army_transport_parameterized = { ARMY_TYPE = xenomorph_army } } }
												default = {
													log = "unhandled army type for [This.GetName] owned by [This.Owner.GetRealName] - used assault_army"
													prev = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } }
												}
											}
										}
									}
								}
							}
						}
					}
				}
				delete_fleet = this
			}
		}
	}
}

# triggered by on_leader_species_changed
# root = leader, post-modification
# from = species, pre-modification (if known)
leader_event = {
	id = keep_leaders.7
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		OR = {
			has_leader_flag = force_gender_match_species
			has_nonbinary_leaders_active = no
		}
		NOT = { has_leader_flag = leader_replaced_by_clone }
		exists = from
		from = { is_scope_type = species }
		klfis_leader_new_species_allows_current_gender = no
	}
	immediate = {
		klfis_leader_transferred_match_gender_to_species = yes
	}
}

# keep robotic only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.10
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.10 keep robotic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species_lenient = yes
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep organic only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.11
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.11 keep organic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species = no
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep same species only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.12
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.12 keep same species only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_same_species = event_target:potential_owner
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: uncybernetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.13
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.13 assimilation (uncyborg priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_genetic_assimilation = yes
				try_apply_psionic_assimilation = yes
				try_apply_uncyborg_assimilation = yes
				# no synthetic assimilation since thematically this is about making leaders fully organic
				try_apply_unmachine_assimilation = yes
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep hive only
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.14
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_utopia = yes
		is_regular_hive_empire = yes
	}
	immediate = {
		log = "keep_leaders.14 keep hive only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_hive_species = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep 'em all!
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.15
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			is_regular_empire = yes
			AND = {
				has_battle_thrall_military_leaders_active = yes
				has_valid_civic = civic_machine_servitor
			}
		}
	}
	immediate = {
		log = "keep_leaders.15 keep as many as possible"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_potential_transfer_without_assimilation = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: synthetic/unmachine before biological assimilations
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.16
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.16 assimilation (synthetic/unmachine priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_synthetic_assimilation = yes
				try_apply_unmachine_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = synthetic_assimilation
							has_leader_flag = unmachine_assimilation
						}
					}
					try_apply_cyborg_assimilation = yes
					try_apply_genetic_assimilation = yes
					try_apply_psionic_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: cybernetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.17
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.17 assimilation (cybernetic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_cyborg_assimilation = yes
				try_apply_genetic_assimilation = yes
				try_apply_psionic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = genetic_assimilation
							has_leader_flag = psionic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: psionic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.18
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.18 assimilation (psionic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_psionic_assimilation = yes
				try_apply_cyborg_assimilation = yes
				try_apply_genetic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = psionic_assimilation
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = genetic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# assimilate: genetic assimilation before others (synthetic/unmachine won't fire if any biological assimilations took effect)
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.19
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		OR = {
			has_synthethic_dawn = yes
			has_utopia = yes
		}
	}
	immediate = {
		log = "keep_leaders.19 assimilation (genetic priority)"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				set_variable = {
					which = assimilation_type_counter
					value = 0
				}
				species = { save_event_target_as = prepared_species }
				try_apply_genetic_assimilation = yes
				try_apply_cyborg_assimilation = yes
				try_apply_psionic_assimilation = yes
				if = {
					limit = {
						NOR = {
							has_leader_flag = genetic_assimilation
							has_leader_flag = cybernetic_assimilation
							has_leader_flag = psionic_assimilation
						}
					}
					try_apply_synthetic_assimilation = yes
					try_apply_unmachine_assimilation = yes
				}
				complete_assimilation_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# necrophage
# root = country, actor
# from = country, leader storage
country_event = {
	id = keep_leaders.20
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_necroids = yes
		is_necrophage_empire = yes
	}
	immediate = {
		log = "keep_leaders.20 necrophage"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		from = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				species = { save_event_target_as = former_species }
				if = {
					limit = { is_robotic_species = no }
					if = {
						limit = {
							OR = {
								is_hive_species = yes
								event_target:potential_owner = {
									OR = {
										has_valid_civic = civic_fanatic_purifiers
										has_policy_flag = purge_allowed
									}
								}
							}
							NAND = {
								has_citizenship_type = {
									country = event_target:potential_owner
									type = citizenship_purge
								}
								has_living_standard = {
									country = event_target:potential_owner
									type = living_standard_none
								}
								has_purge_type = {
									country = event_target:potential_owner
									type = purge_necrophage
								}
							}
						}
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_purge
							cooldown = no
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_none
							cooldown = no
						}
						set_purge_type = {
							country = event_target:potential_owner
							type = purge_necrophage
							cooldown = no
						}
					}
					# if you necrophage them, you lose the secret hive magic
					if = {
						limit = { has_leader_flag = former_gestalt_ruler }
						remove_leader_flag = former_gestalt_ruler
					}
					unassign_leader = this
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					change_leader_portrait = event_target:potential_owner
					try_assign_retained_leader_to_former_assignment = yes
					fire_on_action = {
						on_action = on_leader_species_changed
						scopes = { from = event_target:former_species }
					}
				}
				else_if = {
					limit = {
						is_robotic_species = yes
						event_target:potential_owner = { allows_ai_leaders = yes }
						is_bypass_leader_restriction_honored_protectors = yes
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# gatekeeper to potentially keep aquatic stored leaders after being drenched by the Deluge Machine
# triggered by on_planet_transfer
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.21
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_drenched@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) drenched by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = {
				event_target:variable_storage = {
					check_variable = {
						which = leader_aquatic_accumulator
						value > 0
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_aquatic_species = no }
					kill_leader = {
						show_notification = no
						fire = yes
					}
				}
			}
			from = {
				country_event = {
					id = keep_leaders.1
					scopes = {
						from = prev.fromfrom
						fromfrom = prev
					}
				}
			}
		}
	}
}

# window with options to potentially keep the stored leaders after being cyborgized by the Nanobot Diffuser
# triggered by keep_leaders.31
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.30
	title = keep_leaders.30.title
	desc = keep_leaders.30.desc
	picture = GFX_evt_gray_gooed_planet
	show_sound = event_machinery
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		has_synthethic_dawn = yes
		exists = from
		exists = fromfrom
		from = { has_valid_civic = civic_machine_assimilator }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = nanobot_assimilated@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		prepare_for_primitive_planet_transferred = yes
	}
	# assimilate: assimilator
	option = {
		name = keep_leaders.30.a
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			from = {
				OR = {
					has_valid_civic = civic_machine_assimilator # explicit to get the icon to show
					hidden_trigger = { is_machine_empire = yes }
				}
			}
		}
		allow = { from = { has_valid_civic = civic_machine_assimilator } }
		ai_chance = { factor = 20 }
		from = {
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				society_research = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_organic_non_cyborg_accumulator
			}
			hidden_effect = {
				country_event = {
					id = keep_leaders.17
					scopes = { from = event_target:storage_owner }
				}
			}
		}
	}
	# keep none (nice)
	option = {
		name = keep_leaders.30.b
		custom_tooltip = keep_leaders.30.b.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { from = { has_authority = auth_machine_intelligence } } # explicit to get the icon to show
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			from = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being cyborgized by the Nanobot Diffuser
# triggered by on_planet_transfer
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.31
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		has_synthethic_dawn = yes
		exists = from
		exists = fromfrom
		from = { has_valid_civic = civic_machine_assimilator }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = nanobot_assimilated@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) assimilated via nanobots by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = {
				event_target:variable_storage = {
					OR = {
						check_variable = {
							which = leader_organic_accumulator
							value > 0
						}
						check_variable = {
							which = leader_robotic_accumulator
							value > 0
						}
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			planet_event = {
				id = keep_leaders.30
				scopes = {
					from = from
					fromfrom = fromfrom
				}
			}
		}
	}
}

# window with options to potentially keep the stored leaders after being necrophaged by the Necrophagic Spore Diffuser
# triggered by keep_leaders.41
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.40
	title = keep_leaders.40.title
	desc = keep_leaders.40.desc
	picture = GFX_evt_gray_gooed_planet
	show_sound = event_necrophage
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		has_necroids = yes
		exists = from
		exists = fromfrom
		from = { is_necrophage_empire = yes }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_necrophaged@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		prepare_for_primitive_planet_transferred = yes
	}
	# necrophage
	option = {
		name = keep_leaders.40.a
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = { has_necroids = yes }
			# doesn't use a trigger so that this will be translated into an icon
			from = {
				has_origin = origin_necrophage
				hidden_trigger = { has_trait = trait_necrophage }
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = NECROPHAGE_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			custom_tooltip = {
				fail_text = CANNOT_NECROPHAGE_MACHINES_NO_X
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = no
					}
				}
			}
		}
		ai_chance = {
			factor = 10
			modifier = {
				factor = 2
				from = { has_policy_flag = purge_allowed }
			}
		}
		from = {
			# necrophage unity
			if = {
				limit = {
					OR = {
						has_active_tradition = tr_harmony_unity_of_self
						has_active_tradition = tr_synchronicity_unity_of_mind
					}
				}
				add_resource = {
					unity = @keep_leaders_civic_reward_base
					mult = event_target:variable_storage.leader_necrophagable_accumulator
				}
			}
			hidden_effect = {
				country_event = {
					id = keep_leaders.20
					scopes = { from = event_target:storage_owner }
				}
			}
		}
	}
	# keep none (nice)
	option = {
		name = {
			text = keep_leaders.40.b
			trigger = { from = { is_hive_empire = no } }
		}
		name = {
			text = keep_leaders.40.b.hive
			trigger = { from = { is_hive_empire = yes } }
		}
		if = {
			limit = { from = { is_hive_empire = no } }
			custom_tooltip = keep_leaders.40.b.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.40.b.hive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			from = {
				OR = {
					is_regular_empire = yes
					has_authority = auth_hive_mind # explicit to get the icon to show
				}
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = { factor = 2 }
	}
	# keep none
	option = {
		name = keep_leaders.40.c
		custom_tooltip = keep_leaders.40.c.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { from = { is_regular_empire = yes } }
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				from = { is_xenophile = no }
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				from = { is_pacifist = no }
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = { factor = 0 }
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			from = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being necrophaged by the Necrophagic Spore Diffuser
# triggered by on_planet_transfer
# root = planet (after ownership change)
# from = country, colossus'd
planet_event = {
	id = keep_leaders.41
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		has_necroids = yes
		exists = from
		exists = fromfrom
		from = { is_necrophage_empire = yes }
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = orbitally_necrophaged@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) necrophaged by [From.GetRealName]"
		prepare_for_primitive_planet_transferred = yes
		if = {
			limit = {
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			planet_event = {
				id = keep_leaders.40
				scopes = {
					from = from
					fromfrom = fromfrom
				}
			}
		}
	}
}

# gatekeeper to potentially keep stored leaders after being made believers by the Divine Enforcer
# triggered by on_planet_transfer
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.51
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = { has_owner = yes }
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			has_country_flag = divinely_enforced@prev
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		log = "colossus fired: [This.GetName] ([FromFrom.GetRealName]) had divine belief enforced by [From.GetRealName]"
		if = {
			limit = {
				event_target:variable_storage = {
					check_variable = {
						which = leader_organic_non_cyborg_accumulator
						value > 0
					}
				}
			}
			fromfrom = { set_country_flag = colossus_transfer_handled@prev }
			event_target:storage_owner = {
				every_owned_leader = {
					limit = {
						OR = {
							is_robotic_species = yes
							is_cyborg_species = yes
						}
					}
					kill_leader = {
						show_notification = no
						fire = yes
					}
				}
			}
			from = {
				country_event = {
					id = keep_leaders.1
					scopes = {
						from = prev.fromfrom
						fromfrom = prev
					}
				}
			}
		}
	}
}

# this event is intended to run after all other on_planet_transfer handlers and deletes the container country if it wasn't flagged as handled
# triggered by on_planet_transfer
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
planet_event = {
	id = keep_leaders.99
	hide_window = yes
	is_triggered_only = yes
	pre_triggers = {
		has_owner = yes
	}
	trigger = {
		exists = from
		exists = fromfrom
		fromfrom = {
			has_country_flag = colossus_transfer@prev
			NOT = { has_country_flag = colossus_transfer_handled@prev }
			# if you are a developer, have your handler set the colossus_transfer_handled@planet to preserve the container country beyond the "on_planet_transfer" on_action
		}
		has_leader_storage_from_country_to_planet_owner = yes
	}
	immediate = {
		random_country = {
			limit = {
				is_country_type = neutral_faction
				has_country_flag = former_owner@fromfrom
			}
			destroy_country = yes
		}
	}
}

# triggered by on_leader_death
# this = country
# from = leader
country_event = {
	id = keep_leaders.100
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		exists = from
		from = { has_leader_flag = former_gestalt_ruler }
		any_owned_pop_species = { is_same_species = from }
	}
	immediate = {
		set_country_flag = disable_gender_clones_on_leader_spawned
		log = "keep_leaders.100 former gestalt leader [From.GetName] death"
		create_leader = {
			name = random
			class = ruler
			species = from
			effect = {
				save_event_target_as = age_proxy
			}
		}
		clone_leader = {
			target = from
			effect = {
				set_leader_flag = former_gestalt_ruler_clone
				set_age = event_target:age_proxy.trigger:leader_age
				event_target:age_proxy = {
					kill_leader = {
						show_notification = no
						fire = yes
					}
				}
				save_event_target_as = exiled_former_gestalt_ruler
				exile_leader_as = exiled_former_gestalt_ruler@this
				owner = { remove_country_flag = disable_gender_clones_on_leader_spawned }
			}
		}
		country_event = {
			id = keep_leaders.101
			scopes = { from = event_target:exiled_former_gestalt_ruler }
			days = 30
			random = 60
		}
	}
}

# the "dead" gestalt leader re-emerges 1-3 months after keep_leaders.100
# this = country
# from = the exiled leader
country_event = {
	id = keep_leaders.101
	is_triggered_only = yes
	title = keep_leaders.101.title
	desc = {
		text = keep_leaders.101.desc
		trigger = {
			is_hive_empire = no
			is_machine_empire = no
		}
	}
	desc = {
		text = keep_leaders.101.desc.hive
		trigger = { is_hive_empire = yes }
	}
	desc = {
		text = keep_leaders.101.desc.mach
		trigger = { is_machine_empire = yes }
	}
	picture = {
		trigger = { from = { is_robotic_species = no } }
		picture = GFX_evt_hive_mind
	}
	picture = {
		trigger = { from = { is_robotic_species = yes } }
		picture = GFX_evt_machine_sapience
	}
	show_sound = {
		trigger = { from = { is_robotic_species = no } }
		sound = event_evolution_mastery
	}
	show_sound = {
		trigger = { from = { is_robotic_species = yes } }
		sound = event_synthetic_evolution
	}
	trigger = {
		exists = from
		from = { has_leader_flag = former_gestalt_ruler_clone }
		any_owned_pop_species = { is_same_species = from }
	}
	immediate = {
		log = "keep_leaders.101 former gestalt leader [From.GetFirstName] respawned"
		from = { save_event_target_as = unexile_leader }
	}
	option = {
		name = INCREDIBLE
		custom_tooltip = keep_leaders.101.a.tooltip
		hidden_effect = {
			create_fleet = {
				name = "unexile leader"
				effect = {
					set_owner = prev
					create_ship = {
						name = random
						random_existing_design = science
					}
					set_leader = event_target:unexile_leader
					save_event_target_as = unexile_fleet
				}
			}
			destroy_fleet = {
				target = event_target:unexile_fleet
				kill_leader = no
				destroy_template = yes
			}
			event_target:unexile_leader = {
				recruitable = no
				recruitable = yes
			}
		}
	}
}